# Notebook Implementation Phase - IoT System with MQTT, Node-RED, ESP32 Simulation

## 1. บทนำ (Introduction)

### 1.1 ความหมาย/การใช้งาน/คืออะไร
Notebook Implementation Phase เป็นขั้นตอนการพัฒนาระบบ IoT บน Notebook เดียว โดยใช้ VirtualBox 7.2 สร้าง Virtual Machines แทนการใช้ Proxmox และจำลอง ESP32 ด้วย Node.js Script แทนการใช้ ESP32 จริง

### 1.2 วัตถุประสงค์
- พัฒนาระบบให้สอดคล้องกับ Design Phase
- ใช้เวลาน้อยที่สุด ง่ายที่สุด เพื่อให้ทำได้ภายใน 24 ชั่วโมง
- เน้นการทำงานที่จำเป็นและให้คะแนนสูงสุด
- มีคำสั่งและโค้ดที่พร้อมใช้งานจริง
- ทำงานบน Notebook เดียวด้วย VirtualBox

### 1.3 สภาพแวดล้อมการพัฒนา
- **Host OS**: Windows 10
- **Working Directory**: `D:\Skill-PWS\`
- **Virtualization**: VirtualBox 7.2
- **Network**: Internal Network (172.16.10.0/24)
- **VMs**:
  - Git Server: `git.sisat.lan` - IP: `172.16.10.20/24`
  - Production Server: `prod.sisat.lan` - IP: `172.16.10.10/24`
- **ESP32 Simulation**: Node.js Script

### 1.4 โครงสร้างการพัฒนา
1. **VirtualBox Setup** - ติดตั้ง VirtualBox และสร้าง VMs
2. **Network Configuration** - ตั้งค่า Network สำหรับ VMs
3. **DevOps** - ติดตั้ง Docker, GitLab, CI/CD
4. **Database** - สร้าง Database Schema และ Data
5. **Backend** - พัฒนา Node.js API (บน Windows Host)
6. **Frontend** - พัฒนา Vue 3 + Nuxt 3 (บน Windows Host)
7. **MQTT & Node-RED** - ตั้งค่า MQTT Broker และ Node-RED
8. **ESP32 Simulation** - สร้าง Node.js Script จำลอง ESP32
9. **Docker Compose** - สร้าง docker-compose.yml
10. **Testing** - ทดสอบระบบทั้งหมด

---

## 2. VirtualBox Setup

### 2.1 ติดตั้ง VirtualBox 7.2

#### 2.1.1 Download และติดตั้ง VirtualBox

**ขั้นตอนการทำ:**

1. **Download VirtualBox:**
   - ไปที่ https://www.virtualbox.org/wiki/Downloads
   - Download VirtualBox 7.2 สำหรับ Windows
   - Download VirtualBox Extension Pack (ถ้าต้องการ)

2. **ติดตั้ง VirtualBox:**
   - Run Installer และติดตั้งตาม Wizard
   - ติดตั้ง VirtualBox Extension Pack (ถ้า download มา)

3. **ตรวจสอบการติดตั้ง:**
   ```bash
   # เปิด Command Prompt หรือ PowerShell
   VBoxManage --version
   ```

---

### 2.2 สร้าง Virtual Machines

#### 2.2.1 สร้าง VM1: Git Server

**ขั้นตอนการทำ:**

1. **Download Ubuntu 24.04 LTS Server ISO:**
   - ไปที่ https://ubuntu.com/download/server
   - Download Ubuntu 24.04 LTS Server ISO

2. **สร้าง VM ใน VirtualBox:**
   - เปิด VirtualBox Manager
   - คลิก "New" หรือ "เครื่องใหม่"
   - ตั้งค่า:
     - **Name**: `git-server`
     - **Type**: Linux
     - **Version**: Ubuntu (64-bit)
     - **Memory**: 4096 MB (4 GB)
     - **Hard disk**: Create a virtual hard disk now
     - **Hard disk file type**: VDI (VirtualBox Disk Image)
     - **Storage on physical hard disk**: Dynamically allocated
     - **Size**: 20 GB

3. **ตั้งค่า Network:**
   - เลือก VM > Settings > Network
   - **Adapter 1**:
     - Enable Network Adapter: ✓
     - Attached to: Internal Network
     - Name: `iot-network`
   - **Adapter 2** (Optional - สำหรับ Internet):
     - Enable Network Adapter: ✓
     - Attached to: NAT

4. **ติดตั้ง Ubuntu:**
   - Start VM
   - เลือก Ubuntu ISO ที่ download มา
   - ติดตั้ง Ubuntu ตาม Wizard
   - ตั้งค่า:
     - Hostname: `git.sisat.lan`
     - User: `it`
     - Password: `12345678`
     - Static IP: `172.16.10.20/24`
     - Gateway: (เว้นว่างไว้ - Internal Network ไม่จำเป็นต้องมี Gateway)
     - DNS: `8.8.8.8` (ถ้ามี NAT Adapter สำหรับ Internet)

**วิธีเช็ค:**
```bash
# SSH เข้า VM (จาก Host Windows)
ssh it@172.16.10.20

# หรือใช้ VirtualBox Console
# เช็ค Network
ip addr show
ping 8.8.8.8
```

---

#### 2.2.2 สร้าง VM2: Production Server

**ขั้นตอนการทำ:**

1. **สร้าง VM ใน VirtualBox:**
   - เปิด VirtualBox Manager
   - คลิก "New"
   - ตั้งค่า:
     - **Name**: `production-server`
     - **Type**: Linux
     - **Version**: Ubuntu (64-bit)
     - **Memory**: 4096 MB (4 GB)
     - **Hard disk**: Create a virtual hard disk now
     - **Hard disk file type**: VDI
     - **Storage on physical hard disk**: Dynamically allocated
     - **Size**: 30 GB

2. **ตั้งค่า Network:**
   - เลือก VM > Settings > Network
   - **Adapter 1**:
     - Enable Network Adapter: ✓
     - Attached to: Internal Network
     - Name: `iot-network`
   - **Adapter 2** (Optional - สำหรับ Internet):
     - Enable Network Adapter: ✓
     - Attached to: NAT

3. **ติดตั้ง Ubuntu:**
   - Start VM
   - เลือก Ubuntu ISO
   - ติดตั้ง Ubuntu ตาม Wizard
   - ตั้งค่า:
     - Hostname: `prod.sisat.lan`
     - User: `it`
     - Password: `12345678`
     - Static IP: `172.16.10.10/24`
     - Gateway: (เว้นว่างไว้ - Internal Network ไม่จำเป็นต้องมี Gateway)
     - DNS: `8.8.8.8` (ถ้ามี NAT Adapter สำหรับ Internet)

**วิธีเช็ค:**
```bash
# SSH เข้า VM (จาก Host Windows)
ssh it@172.16.10.10

# เช็ค Network
ip addr show
ping 8.8.8.8
```

---

### 2.3 ตั้งค่า Network Configuration บน VMs

#### 2.3.1 ตั้งค่า Static IP บน Git Server

**คำสั่งตั้งค่า:**

```bash
# SSH เข้า Git Server
ssh it@172.16.10.20

# แก้ไข Network Configuration
sudo nano /etc/netplan/00-installer-config.yaml
```

**เนื้อหาไฟล์:**
```yaml
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: false
      addresses:
        - 172.16.10.20/24
      # routes: (ไม่จำเป็นสำหรับ Internal Network)
      #   - to: default
      #     via: 172.16.10.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
```

**Apply Configuration:**
```bash
sudo netplan apply
ip addr show
```

---

#### 2.3.2 ตั้งค่า Static IP บน Production Server

**คำสั่งตั้งค่า:**

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# แก้ไข Network Configuration
sudo nano /etc/netplan/00-installer-config.yaml
```

**เนื้อหาไฟล์:**
```yaml
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: false
      addresses:
        - 172.16.10.10/24
      # routes: (ไม่จำเป็นสำหรับ Internal Network)
      #   - to: default
      #     via: 172.16.10.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4
```

**Apply Configuration:**
```bash
sudo netplan apply
ip addr show
```

---

### 2.4 ตั้งค่า Host File บน Windows

**แก้ไขไฟล์ `C:\Windows\System32\drivers\etc\hosts` (ต้อง Run as Administrator):**

```
172.16.10.20 git.sisat.lan
172.16.10.10 prod.sisat.lan
```

**วิธีเช็ค:**
```bash
# บน Windows PowerShell (Run as Administrator)
ping git.sisat.lan
ping prod.sisat.lan
```

---

## 3. DevOps Setup

### 3.1 ติดตั้ง Docker บน Production Server

#### 3.1.1 ติดตั้ง Docker

**คำสั่งติดตั้ง Docker:**

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# Update System
sudo apt update
sudo apt upgrade -y

# ติดตั้ง Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# เพิ่ม User เข้า Docker Group
sudo usermod -aG docker it

# ติดตั้ง Docker Compose
sudo apt install docker-compose -y

# Restart เพื่อให้ Docker Group มีผล
# Logout และ Login ใหม่ หรือ
newgrp docker

# ตรวจสอบ Docker
docker --version
docker-compose --version
```

**วิธีเช็ค:**
```bash
# ทดสอบ Docker
docker run hello-world

# ดู Docker Status
sudo systemctl status docker
```

---

### 3.2 ติดตั้ง GitLab บน Git Server

#### 3.2.1 ติดตั้ง GitLab ด้วย Docker

**คำสั่งติดตั้ง GitLab:**

```bash
# SSH เข้า Git Server
ssh it@172.16.10.20

# ติดตั้ง Docker (ทำเหมือน Production Server)
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker it
newgrp docker

# สร้าง Directory สำหรับ GitLab
sudo mkdir -p /opt/gitlab/{config,logs,data}

# Run GitLab Container
sudo docker run -d \
  --hostname git.sisat.lan \
  --name gitlab \
  --restart always \
  -p 80:80 \
  -p 443:443 \
  -p 22:22 \
  -v /opt/gitlab/config:/etc/gitlab \
  -v /opt/gitlab/logs:/var/log/gitlab \
  -v /opt/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce:latest

# รอให้ GitLab Start (ใช้เวลาประมาณ 5-10 นาที)
sudo docker logs -f gitlab
```

**วิธีเช็ค:**
```bash
# ดู GitLab Status
sudo docker ps | grep gitlab

# ดู GitLab Logs
sudo docker logs gitlab

# ดู Root Password
sudo docker exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password

# ทดสอบ GitLab Web UI
curl http://172.16.10.20
```

#### 3.2.2 ตั้งค่า GitLab

**ขั้นตอนการทำ:**

1. **เข้าสู่ GitLab:**
   - เปิด Browser: http://172.16.10.20
   - Login ด้วย root และ password จาก initial_root_password

2. **ตั้งค่า Root Password:**
   - เปลี่ยน Root Password เป็น password ที่ต้องการ

3. **สร้าง Project:**
   - คลิก "New Project"
   - เลือก "Create blank project"
   - Project name: `iot-system`
   - Visibility: Private

---

## 4. Database Setup

### 4.1 ติดตั้ง MariaDB ด้วย Docker

#### 4.1.1 สร้าง Docker Compose สำหรับ Database

**สร้างไฟล์ docker-compose.db.yml:**

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# สร้าง Directory
mkdir -p ~/iot-system/database
cd ~/iot-system/database

# สร้างไฟล์ docker-compose.db.yml
cat > docker-compose.db.yml << 'EOF'
version: '3.8'

services:
  db:
    image: mariadb:10.11
    container_name: iot-db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword123
      MYSQL_DATABASE: iot_db
      MYSQL_USER: iot_user
      MYSQL_PASSWORD: iot_password_123
    ports:
      - "3306:3306"
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - iot_network

volumes:
  db_data:

networks:
  iot_network:
    driver: bridge
EOF

# สร้าง Network (ถ้ายังไม่มี)
docker network create iot_network 2>/dev/null || true

# Run Database
docker-compose -f docker-compose.db.yml up -d

# ตรวจสอบ
docker ps | grep iot-db
```

**วิธีเช็ค:**
```bash
# เช็ค Database Connection
docker exec -it iot-db mysql -u root -prootpassword123 -e "SHOW DATABASES;"

# เช็ค User
docker exec -it iot-db mysql -u root -prootpassword123 -e "SELECT User, Host FROM mysql.user;"
```

---

### 4.2 สร้าง Database Schema

#### 4.2.1 สร้าง Schema และ Tables

**สร้างไฟล์ schema.sql:**

```bash
# สร้างไฟล์ schema.sql
cat > schema.sql << 'EOF'
-- สร้าง Database
CREATE DATABASE IF NOT EXISTS iot_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

USE iot_db;

-- ตาราง users
CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    role ENUM('admin', 'user_level_1', 'user_level_2') NOT NULL DEFAULT 'user_level_2',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ตาราง sensor_data
CREATE TABLE IF NOT EXISTS sensor_data (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    sensor_type VARCHAR(50) NOT NULL,
    sensor_value DECIMAL(10,2) NOT NULL,
    mqtt_topic VARCHAR(255) NOT NULL,
    timestamp DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_timestamp (timestamp),
    INDEX idx_sensor_type (sensor_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ตาราง device_config
CREATE TABLE IF NOT EXISTS device_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    sensor_data_id INT,
    device_name VARCHAR(100) NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    mqtt_topic VARCHAR(255) NOT NULL,
    status ENUM('active', 'inactive', 'maintenance') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (sensor_data_id) REFERENCES sensor_data(id) ON DELETE SET NULL,
    INDEX idx_device_name (device_name),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
EOF

# Execute SQL
docker exec -i iot-db mysql -u root -prootpassword123 < schema.sql
```

**วิธีเช็ค:**
```bash
# เช็ค Tables
docker exec -it iot-db mysql -u iot_user -piot_password_123 iot_db -e "SHOW TABLES;"

# เช็ค Table Structure
docker exec -it iot-db mysql -u iot_user -piot_password_123 iot_db -e "DESCRIBE users;"
```

---

### 4.3 เพิ่มข้อมูลเริ่มต้น

#### 4.3.1 Hash Password และเพิ่ม Users

**สร้างไฟล์ hash-password.js:**

```bash
# บน Windows Host (D:\Skill-PWS\)
cd D:\Skill-PWS
mkdir database
cd database

# สร้างไฟล์ hash-password.js
cat > hash-password.js << 'EOF'
const bcrypt = require('bcrypt');

// ทุก user ใช้ password เดียวกัน: 1234
const password = '1234';

async function hashPassword() {
    const hash = await bcrypt.hash(password, 10);
    console.log(`Password: ${password}`);
    console.log(`Hash: ${hash}`);
    console.log('---');
    console.log('ใช้ Hash นี้สำหรับทุก user (admin, user1, user2)');
}

hashPassword().catch(console.error);
EOF

# ติดตั้ง bcrypt
npm init -y
npm install bcrypt

# Run Script
node hash-password.js
```

**สร้างไฟล์ seed-data.sql:**

```bash
# สร้างไฟล์ seed-data.sql (ทุก user ใช้ password: 1234)
cat > seed-data.sql << 'EOF'
USE iot_db;

-- เพิ่ม Users (ทุก user ใช้ password: 1234)
-- Hash สำหรับ password "1234": $2b$10$BGb7Jb2uYApgo5KO06YY5uKpJTyrIo0zX6BSZZ6aHEwFMDuzAeSAm
-- 
-- หมายเหตุ: 
-- - ทุก user (admin, user1, user2) ใช้ password เดียวกัน: 1234
-- - Hash นี้สร้างจาก bcrypt.hash('1234', 10)
--
INSERT INTO users (username, password, email, role) VALUES
('admin', '$2b$10$BGb7Jb2uYApgo5KO06YY5uKpJTyrIo0zX6BSZZ6aHEwFMDuzAeSAm', 'admin@sisat.lan', 'admin');

INSERT INTO users (username, password, email, role) VALUES
('user1', '$2b$10$BGb7Jb2uYApgo5KO06YY5uKpJTyrIo0zX6BSZZ6aHEwFMDuzAeSAm', 'user1@sisat.lan', 'user_level_1');

INSERT INTO users (username, password, email, role) VALUES
('user2', '$2b$10$BGb7Jb2uYApgo5KO06YY5uKpJTyrIo0zX6BSZZ6aHEwFMDuzAeSAm', 'user2@sisat.lan', 'user_level_2');
EOF

# Copy ไฟล์ไปยัง Production Server
scp seed-data.sql it@172.16.10.10:~/iot-system/database/

# Execute SQL บน Production Server
ssh it@172.16.10.10 "cd ~/iot-system/database && docker exec -i iot-db mysql -u root -prootpassword123 < seed-data.sql"
```

**วิธีเช็ค:**
```bash
# เช็ค Users
ssh it@172.16.10.10 "docker exec -it iot-db mysql -u iot_user -piot_password_123 iot_db -e 'SELECT id, username, email, role FROM users;'"
```

---

## 5. Backend Implementation (บน Windows Host)

### 5.1 สร้าง Backend Project

#### 5.1.1 สร้างโครงสร้าง Project

**คำสั่งสร้าง Project:**

```bash
# บน Windows Host (D:\Skill-PWS\)
cd D:\Skill-PWS
mkdir backend
cd backend

# Initialize Node.js Project
npm init -y

# ติดตั้ง Dependencies
npm install express cors dotenv jsonwebtoken bcrypt express-validator multer mysql2

# ติดตั้ง Dev Dependencies
npm install --save-dev nodemon
```

**โครงสร้างไฟล์:**
```
backend/
├─ package.json
├─ .env
├─ server.js
├─ config/
│   └─ database.js
├─ routes/
│   ├─ auth.js
│   ├─ users.js
│   ├─ sensorData.js
│   ├─ devices.js
│   └─ upload.js
├─ controllers/
│   ├─ authController.js
│   ├─ userController.js
│   ├─ sensorDataController.js
│   └─ deviceController.js
├─ middleware/
│   ├─ auth.js
│   └─ errorHandler.js
└─ utils/
    └─ hashPassword.js
```

---

### 5.2 สร้างไฟล์ Backend

#### 5.2.1 สร้างไฟล์ server.js

**สร้างไฟล์ server.js:**

```javascript
// server.js
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const sensorDataRoutes = require('./routes/sensorData');
const deviceRoutes = require('./routes/devices');
const uploadRoutes = require('./routes/upload');
const errorHandler = require('./middleware/errorHandler');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/sensor-data', sensorDataRoutes);
app.use('/api/devices', deviceRoutes);
app.use('/api/upload', uploadRoutes);

// Health Check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// Error Handler
app.use(errorHandler);

// Start Server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

#### 5.2.2 สร้างไฟล์ config/database.js

**สร้างไฟล์ config/database.js:**

```javascript
// config/database.js
const mysql = require('mysql2/promise');
const dotenv = require('dotenv');

dotenv.config();

const pool = mysql.createPool({
  host: process.env.DB_HOST || '172.16.10.10',
  port: process.env.DB_PORT || 3306,
  user: process.env.DB_USER || 'iot_user',
  password: process.env.DB_PASSWORD || 'iot_password_123',
  database: process.env.DB_NAME || 'iot_db',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

module.exports = pool;
```

#### 5.2.3 สร้างไฟล์ .env

**สร้างไฟล์ .env:**

```bash
# .env
NODE_ENV=development
PORT=3000
JWT_SECRET=your-secret-key-change-this-in-production
JWT_EXPIRE=24h

DB_HOST=172.16.10.10
DB_PORT=3306
DB_USER=iot_user
DB_PASSWORD=iot_password_123
DB_NAME=iot_db

UPLOAD_DIR=./uploads
```

---

### 5.3 สร้าง Authentication

#### 5.3.1 สร้างไฟล์ middleware/auth.js

**สร้างไฟล์ middleware/auth.js:**

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');
const dotenv = require('dotenv');

dotenv.config();

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({
      status: 'error',
      message: 'Access token required'
    });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(403).json({
        status: 'error',
        message: 'Invalid or expired token'
      });
    }
    req.user = decoded;
    next();
  });
};

const isAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({
      status: 'error',
      message: 'Access denied. Admin only.'
    });
  }
  next();
};

const canWrite = (req, res, next) => {
  if (req.user.role === 'user_level_2') {
    return res.status(403).json({
      status: 'error',
      message: 'Read-only access. Cannot modify data.'
    });
  }
  next();
};

module.exports = {
  authenticateToken,
  isAdmin,
  canWrite
};
```

#### 5.3.2 สร้างไฟล์ routes/auth.js

**สร้างไฟล์ routes/auth.js:**

```javascript
// routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { authenticateToken } = require('../middleware/auth');

router.post('/login', authController.login);
router.post('/logout', authenticateToken, authController.logout);
router.get('/me', authenticateToken, authController.getMe);

module.exports = router;
```

#### 5.3.3 สร้างไฟล์ controllers/authController.js

**สร้างไฟล์ controllers/authController.js:**

```javascript
// controllers/authController.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const pool = require('../config/database');
const dotenv = require('dotenv');

dotenv.config();

const login = async (req, res, next) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({
        status: 'error',
        message: 'Username and password are required'
      });
    }

    // Query User
    const [users] = await pool.execute(
      'SELECT * FROM users WHERE username = ?',
      [username]
    );

    if (users.length === 0) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid username or password'
      });
    }

    const user = users[0];

    // Verify Password
    const isValid = await bcrypt.compare(password, user.password);

    if (!isValid) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid username or password'
      });
    }

    // Generate JWT Token
    const token = jwt.sign(
      {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRE || '24h' }
    );

    res.json({
      status: 'success',
      message: 'Login successful',
      data: {
        token,
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

const logout = (req, res) => {
  res.json({
    status: 'success',
    message: 'Logout successful'
  });
};

const getMe = async (req, res, next) => {
  try {
    const userId = req.user.id;

    const [users] = await pool.execute(
      'SELECT id, username, email, role, created_at FROM users WHERE id = ?',
      [userId]
    );

    if (users.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }

    res.json({
      status: 'success',
      data: users[0]
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  login,
  logout,
  getMe
};
```

---

### 5.4 สร้าง API Routes

#### 5.4.1 สร้างไฟล์ routes/sensorData.js

**สร้างไฟล์ routes/sensorData.js:**

```javascript
// routes/sensorData.js
const express = require('express');
const router = express.Router();
const sensorDataController = require('../controllers/sensorDataController');
const { authenticateToken, canWrite } = require('../middleware/auth');

router.get('/', authenticateToken, sensorDataController.getAll);
router.get('/:id', authenticateToken, sensorDataController.getById);
router.post('/', authenticateToken, canWrite, sensorDataController.create);
router.put('/:id', authenticateToken, canWrite, sensorDataController.update);
router.delete('/:id', authenticateToken, canWrite, sensorDataController.delete);

module.exports = router;
```

#### 5.4.2 สร้างไฟล์ controllers/sensorDataController.js

**สร้างไฟล์ controllers/sensorDataController.js:**

```javascript
// controllers/sensorDataController.js
const pool = require('../config/database');

const getAll = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const role = req.user.role;
    const { page = 1, limit = 10, sensor_type } = req.query;

    let query = 'SELECT * FROM sensor_data WHERE 1=1';
    const params = [];

    // Filter by user_id if not admin
    if (role !== 'admin') {
      query += ' AND user_id = ?';
      params.push(userId);
    }

    // Filter by sensor_type
    if (sensor_type) {
      query += ' AND sensor_type = ?';
      params.push(sensor_type);
    }

    query += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';
    const offset = (page - 1) * limit;
    params.push(parseInt(limit), offset);

    const [data] = await pool.execute(query, params);

    // Get total count
    let countQuery = 'SELECT COUNT(*) as total FROM sensor_data WHERE 1=1';
    const countParams = [];
    if (role !== 'admin') {
      countQuery += ' AND user_id = ?';
      countParams.push(userId);
    }
    if (sensor_type) {
      countQuery += ' AND sensor_type = ?';
      countParams.push(sensor_type);
    }

    const [countResult] = await pool.execute(countQuery, countParams);
    const total = countResult[0].total;

    res.json({
      status: 'success',
      message: 'Sensor data retrieved successfully',
      data: {
        items: data,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          totalPages: Math.ceil(total / limit)
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

const getById = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const role = req.user.role;

    let query = 'SELECT * FROM sensor_data WHERE id = ?';
    const params = [id];

    if (role !== 'admin') {
      query += ' AND user_id = ?';
      params.push(userId);
    }

    const [data] = await pool.execute(query, params);

    if (data.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Sensor data not found'
      });
    }

    res.json({
      status: 'success',
      data: data[0]
    });
  } catch (error) {
    next(error);
  }
};

const create = async (req, res, next) => {
  try {
    const { sensor_type, sensor_value, mqtt_topic, timestamp } = req.body;
    const userId = req.user.id;

    if (!sensor_type || sensor_value === undefined || !mqtt_topic) {
      return res.status(400).json({
        status: 'error',
        message: 'sensor_type, sensor_value, and mqtt_topic are required'
      });
    }

    const [result] = await pool.execute(
      'INSERT INTO sensor_data (user_id, sensor_type, sensor_value, mqtt_topic, timestamp) VALUES (?, ?, ?, ?, ?)',
      [userId, sensor_type, sensor_value, mqtt_topic, timestamp || new Date()]
    );

    const [newData] = await pool.execute(
      'SELECT * FROM sensor_data WHERE id = ?',
      [result.insertId]
    );

    res.status(201).json({
      status: 'success',
      message: 'Sensor data created successfully',
      data: newData[0]
    });
  } catch (error) {
    next(error);
  }
};

const update = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { sensor_type, sensor_value, mqtt_topic, timestamp } = req.body;
    const userId = req.user.id;
    const role = req.user.role;

    // Check if data exists and user has permission
    let checkQuery = 'SELECT * FROM sensor_data WHERE id = ?';
    const checkParams = [id];
    if (role !== 'admin') {
      checkQuery += ' AND user_id = ?';
      checkParams.push(userId);
    }

    const [existing] = await pool.execute(checkQuery, checkParams);

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Sensor data not found'
      });
    }

    // Update
    const updateFields = [];
    const updateParams = [];

    if (sensor_type) {
      updateFields.push('sensor_type = ?');
      updateParams.push(sensor_type);
    }
    if (sensor_value !== undefined) {
      updateFields.push('sensor_value = ?');
      updateParams.push(sensor_value);
    }
    if (mqtt_topic) {
      updateFields.push('mqtt_topic = ?');
      updateParams.push(mqtt_topic);
    }
    if (timestamp) {
      updateFields.push('timestamp = ?');
      updateParams.push(timestamp);
    }

    if (updateFields.length === 0) {
      return res.status(400).json({
        status: 'error',
        message: 'No fields to update'
      });
    }

    updateParams.push(id);
    await pool.execute(
      `UPDATE sensor_data SET ${updateFields.join(', ')} WHERE id = ?`,
      updateParams
    );

    const [updated] = await pool.execute(
      'SELECT * FROM sensor_data WHERE id = ?',
      [id]
    );

    res.json({
      status: 'success',
      message: 'Sensor data updated successfully',
      data: updated[0]
    });
  } catch (error) {
    next(error);
  }
};

const delete = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const role = req.user.role;

    // Check if data exists and user has permission
    let checkQuery = 'SELECT * FROM sensor_data WHERE id = ?';
    const checkParams = [id];
    if (role !== 'admin') {
      checkQuery += ' AND user_id = ?';
      checkParams.push(userId);
    }

    const [existing] = await pool.execute(checkQuery, checkParams);

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Sensor data not found'
      });
    }

    await pool.execute('DELETE FROM sensor_data WHERE id = ?', [id]);

    res.json({
      status: 'success',
      message: 'Sensor data deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete
};
```

---

#### 5.4.3 สร้างไฟล์ routes/users.js

**สร้างไฟล์ routes/users.js:**

```javascript
// routes/users.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const { authenticateToken, isAdmin } = require('../middleware/auth');

router.get('/', authenticateToken, isAdmin, userController.getAll);
router.get('/:id', authenticateToken, userController.getById);
router.post('/', authenticateToken, isAdmin, userController.create);
router.put('/:id', authenticateToken, isAdmin, userController.update);
router.delete('/:id', authenticateToken, isAdmin, userController.delete);

module.exports = router;
```

#### 5.4.4 สร้างไฟล์ controllers/userController.js

**สร้างไฟล์ controllers/userController.js:**

```javascript
// controllers/userController.js
const bcrypt = require('bcrypt');
const pool = require('../config/database');

const getAll = async (req, res, next) => {
  try {
    const { page = 1, limit = 10 } = req.query;
    const offset = (page - 1) * limit;

    const [users] = await pool.execute(
      'SELECT id, username, email, role, created_at, updated_at FROM users ORDER BY id DESC LIMIT ? OFFSET ?',
      [parseInt(limit), offset]
    );

    const [countResult] = await pool.execute('SELECT COUNT(*) as total FROM users');
    const total = countResult[0].total;

    res.json({
      status: 'success',
      message: 'Users retrieved successfully',
      data: {
        items: users,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          totalPages: Math.ceil(total / limit)
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

const getById = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const role = req.user.role;

    // Users can only view their own profile unless admin
    if (role !== 'admin' && parseInt(id) !== userId) {
      return res.status(403).json({
        status: 'error',
        message: 'Access denied. You can only view your own profile.'
      });
    }

    const [users] = await pool.execute(
      'SELECT id, username, email, role, created_at, updated_at FROM users WHERE id = ?',
      [id]
    );

    if (users.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }

    res.json({
      status: 'success',
      data: users[0]
    });
  } catch (error) {
    next(error);
  }
};

const create = async (req, res, next) => {
  try {
    const { username, password, email, role } = req.body;

    if (!username || !password || !email) {
      return res.status(400).json({
        status: 'error',
        message: 'username, password, and email are required'
      });
    }

    // Validate role
    const validRoles = ['admin', 'user_level_1', 'user_level_2'];
    const userRole = role || 'user_level_2';
    if (!validRoles.includes(userRole)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid role. Must be one of: admin, user_level_1, user_level_2'
      });
    }

    // Check if username or email already exists
    const [existing] = await pool.execute(
      'SELECT id FROM users WHERE username = ? OR email = ?',
      [username, email]
    );

    if (existing.length > 0) {
      return res.status(409).json({
        status: 'error',
        message: 'Username or email already exists'
      });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const [result] = await pool.execute(
      'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
      [username, hashedPassword, email, userRole]
    );

    const [newUser] = await pool.execute(
      'SELECT id, username, email, role, created_at FROM users WHERE id = ?',
      [result.insertId]
    );

    res.status(201).json({
      status: 'success',
      message: 'User created successfully',
      data: newUser[0]
    });
  } catch (error) {
    next(error);
  }
};

const update = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { email, role, password } = req.body;

    // Check if user exists
    const [existing] = await pool.execute('SELECT * FROM users WHERE id = ?', [id]);

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }

    const updateFields = [];
    const updateParams = [];

    if (email) {
      // Check if email already exists
      const [emailCheck] = await pool.execute(
        'SELECT id FROM users WHERE email = ? AND id != ?',
        [email, id]
      );
      if (emailCheck.length > 0) {
        return res.status(409).json({
          status: 'error',
          message: 'Email already exists'
        });
      }
      updateFields.push('email = ?');
      updateParams.push(email);
    }

    if (role) {
      const validRoles = ['admin', 'user_level_1', 'user_level_2'];
      if (!validRoles.includes(role)) {
        return res.status(400).json({
          status: 'error',
          message: 'Invalid role. Must be one of: admin, user_level_1, user_level_2'
        });
      }
      updateFields.push('role = ?');
      updateParams.push(role);
    }

    if (password) {
      const hashedPassword = await bcrypt.hash(password, 10);
      updateFields.push('password = ?');
      updateParams.push(hashedPassword);
    }

    if (updateFields.length === 0) {
      return res.status(400).json({
        status: 'error',
        message: 'No fields to update'
      });
    }

    updateParams.push(id);
    await pool.execute(
      `UPDATE users SET ${updateFields.join(', ')} WHERE id = ?`,
      updateParams
    );

    const [updated] = await pool.execute(
      'SELECT id, username, email, role, created_at, updated_at FROM users WHERE id = ?',
      [id]
    );

    res.json({
      status: 'success',
      message: 'User updated successfully',
      data: updated[0]
    });
  } catch (error) {
    next(error);
  }
};

const delete = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Check if user exists
    const [existing] = await pool.execute('SELECT id FROM users WHERE id = ?', [id]);

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }

    // Prevent deleting yourself
    if (parseInt(id) === req.user.id) {
      return res.status(400).json({
        status: 'error',
        message: 'Cannot delete your own account'
      });
    }

    await pool.execute('DELETE FROM users WHERE id = ?', [id]);

    res.json({
      status: 'success',
      message: 'User deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete
};
```

---

#### 5.4.5 สร้างไฟล์ routes/devices.js

**สร้างไฟล์ routes/devices.js:**

```javascript
// routes/devices.js
const express = require('express');
const router = express.Router();
const deviceController = require('../controllers/deviceController');
const { authenticateToken, canWrite } = require('../middleware/auth');

router.get('/', authenticateToken, deviceController.getAll);
router.get('/:id', authenticateToken, deviceController.getById);
router.post('/', authenticateToken, canWrite, deviceController.create);
router.put('/:id', authenticateToken, canWrite, deviceController.update);
router.delete('/:id', authenticateToken, canWrite, deviceController.delete);

module.exports = router;
```

#### 5.4.6 สร้างไฟล์ controllers/deviceController.js

**สร้างไฟล์ controllers/deviceController.js:**

```javascript
// controllers/deviceController.js
const pool = require('../config/database');

const getAll = async (req, res, next) => {
  try {
    const { page = 1, limit = 10, status, device_type } = req.query;
    const offset = (page - 1) * limit;

    let query = 'SELECT * FROM device_config WHERE 1=1';
    const params = [];

    if (status) {
      query += ' AND status = ?';
      params.push(status);
    }

    if (device_type) {
      query += ' AND device_type = ?';
      params.push(device_type);
    }

    query += ' ORDER BY created_at DESC LIMIT ? OFFSET ?';
    params.push(parseInt(limit), offset);

    const [devices] = await pool.execute(query, params);

    // Get total count
    let countQuery = 'SELECT COUNT(*) as total FROM device_config WHERE 1=1';
    const countParams = [];
    if (status) {
      countQuery += ' AND status = ?';
      countParams.push(status);
    }
    if (device_type) {
      countQuery += ' AND device_type = ?';
      countParams.push(device_type);
    }

    const [countResult] = await pool.execute(countQuery, countParams);
    const total = countResult[0].total;

    res.json({
      status: 'success',
      message: 'Devices retrieved successfully',
      data: {
        items: devices,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          totalPages: Math.ceil(total / limit)
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

const getById = async (req, res, next) => {
  try {
    const { id } = req.params;

    const [devices] = await pool.execute(
      'SELECT * FROM device_config WHERE id = ?',
      [id]
    );

    if (devices.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Device not found'
      });
    }

    res.json({
      status: 'success',
      data: devices[0]
    });
  } catch (error) {
    next(error);
  }
};

const create = async (req, res, next) => {
  try {
    const { device_name, device_type, mqtt_topic, status, sensor_data_id } = req.body;

    if (!device_name || !device_type || !mqtt_topic) {
      return res.status(400).json({
        status: 'error',
        message: 'device_name, device_type, and mqtt_topic are required'
      });
    }

    // Validate status
    const validStatuses = ['active', 'inactive', 'maintenance'];
    const deviceStatus = status || 'active';
    if (!validStatuses.includes(deviceStatus)) {
      return res.status(400).json({
        status: 'error',
        message: 'Invalid status. Must be one of: active, inactive, maintenance'
      });
    }

    // Check if sensor_data_id exists (if provided)
    if (sensor_data_id) {
      const [sensorData] = await pool.execute(
        'SELECT id FROM sensor_data WHERE id = ?',
        [sensor_data_id]
      );
      if (sensorData.length === 0) {
        return res.status(404).json({
          status: 'error',
          message: 'Sensor data not found'
        });
      }
    }

    const [result] = await pool.execute(
      'INSERT INTO device_config (device_name, device_type, mqtt_topic, status, sensor_data_id) VALUES (?, ?, ?, ?, ?)',
      [device_name, device_type, mqtt_topic, deviceStatus, sensor_data_id || null]
    );

    const [newDevice] = await pool.execute(
      'SELECT * FROM device_config WHERE id = ?',
      [result.insertId]
    );

    res.status(201).json({
      status: 'success',
      message: 'Device created successfully',
      data: newDevice[0]
    });
  } catch (error) {
    next(error);
  }
};

const update = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { device_name, device_type, mqtt_topic, status, sensor_data_id } = req.body;

    // Check if device exists
    const [existing] = await pool.execute(
      'SELECT * FROM device_config WHERE id = ?',
      [id]
    );

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Device not found'
      });
    }

    const updateFields = [];
    const updateParams = [];

    if (device_name) {
      updateFields.push('device_name = ?');
      updateParams.push(device_name);
    }
    if (device_type) {
      updateFields.push('device_type = ?');
      updateParams.push(device_type);
    }
    if (mqtt_topic) {
      updateFields.push('mqtt_topic = ?');
      updateParams.push(mqtt_topic);
    }
    if (status) {
      const validStatuses = ['active', 'inactive', 'maintenance'];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({
          status: 'error',
          message: 'Invalid status. Must be one of: active, inactive, maintenance'
        });
      }
      updateFields.push('status = ?');
      updateParams.push(status);
    }
    if (sensor_data_id !== undefined) {
      if (sensor_data_id !== null) {
        // Check if sensor_data_id exists
        const [sensorData] = await pool.execute(
          'SELECT id FROM sensor_data WHERE id = ?',
          [sensor_data_id]
        );
        if (sensorData.length === 0) {
          return res.status(404).json({
            status: 'error',
            message: 'Sensor data not found'
          });
        }
      }
      updateFields.push('sensor_data_id = ?');
      updateParams.push(sensor_data_id);
    }

    if (updateFields.length === 0) {
      return res.status(400).json({
        status: 'error',
        message: 'No fields to update'
      });
    }

    updateParams.push(id);
    await pool.execute(
      `UPDATE device_config SET ${updateFields.join(', ')} WHERE id = ?`,
      updateParams
    );

    const [updated] = await pool.execute(
      'SELECT * FROM device_config WHERE id = ?',
      [id]
    );

    res.json({
      status: 'success',
      message: 'Device updated successfully',
      data: updated[0]
    });
  } catch (error) {
    next(error);
  }
};

const delete = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Check if device exists
    const [existing] = await pool.execute(
      'SELECT id FROM device_config WHERE id = ?',
      [id]
    );

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Device not found'
      });
    }

    await pool.execute('DELETE FROM device_config WHERE id = ?', [id]);

    res.json({
      status: 'success',
      message: 'Device deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete
};
```

---

### 5.5 สร้าง Error Handler

#### 5.5.1 สร้างไฟล์ middleware/errorHandler.js

**สร้างไฟล์ middleware/errorHandler.js:**

```javascript
// middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  console.error('Error:', err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  res.status(statusCode).json({
    status: 'error',
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

module.exports = errorHandler;
```

---

### 5.6 สร้าง File Upload

#### 5.6.1 สร้างไฟล์ routes/upload.js

**สร้างไฟล์ routes/upload.js:**

```javascript
// routes/upload.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const { authenticateToken } = require('../middleware/auth');
const dotenv = require('dotenv');

dotenv.config();

// Configure Multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, process.env.UPLOAD_DIR || './uploads');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);

    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  }
});

router.post('/', authenticateToken, upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({
      status: 'error',
      message: 'No file uploaded'
    });
  }

  res.json({
    status: 'success',
    message: 'File uploaded successfully',
    data: {
      filename: req.file.filename,
      path: req.file.path,
      size: req.file.size,
      mimetype: req.file.mimetype
    }
  });
});

module.exports = router;
```

---

### 5.7 เพิ่ม Scripts ใน package.json

**แก้ไขไฟล์ package.json:**

```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "IoT System Backend API",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-validator": "^7.0.1",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "mysql2": "^3.6.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

---

## 6. Frontend Implementation (บน Windows Host)

### 6.1 สร้าง Frontend Project

#### 6.1.1 สร้าง Nuxt 3 Project

**คำสั่งสร้าง Project:**

```bash
# บน Windows Host (D:\Skill-PWS\)
cd D:\Skill-PWS
npx nuxi@latest init frontend
cd frontend
npm install
```

#### 6.1.2 ติดตั้ง Dependencies

**คำสั่งติดตั้ง:**

```bash
npm install @nuxtjs/tailwindcss axios jwt-decode pinia @pinia/nuxt
```

#### 6.1.3 ตั้งค่า nuxt.config.ts

**สร้างไฟล์ nuxt.config.ts:**

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt'
  ],
  css: ['~/assets/css/main.css'],
  runtimeConfig: {
    public: {
      apiBase: process.env.API_BASE_URL || 'http://localhost:3000/api'
    }
  },
  devServer: {
    port: 3001,
    host: '0.0.0.0'
  }
})
```

---

### 6.2 สร้าง Authentication

#### 6.2.1 สร้าง Pinia Store

**สร้างไฟล์ stores/auth.js:**

```javascript
// stores/auth.js
import { defineStore } from 'pinia'
import axios from 'axios'

const config = useRuntimeConfig()

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    token: null
  }),

  getters: {
    isAuthenticated: (state) => !!state.token,
    userRole: (state) => state.user?.role
  },

  actions: {
    async login(username, password) {
      try {
        const response = await axios.post(`${config.public.apiBase}/auth/login`, {
          username,
          password
        })

        if (response.data.status === 'success') {
          this.token = response.data.data.token
          this.user = response.data.data.user
          
          // Store in localStorage
          if (process.client) {
            localStorage.setItem('token', this.token)
            localStorage.setItem('user', JSON.stringify(this.user))
          }
          
          return true
        }
        return false
      } catch (error) {
        console.error('Login error:', error)
        return false
      }
    },

    logout() {
      this.user = null
      this.token = null
      if (process.client) {
        localStorage.removeItem('token')
        localStorage.removeItem('user')
      }
      navigateTo('/login')
    },

    loadFromStorage() {
      if (process.client) {
        const token = localStorage.getItem('token')
        const user = localStorage.getItem('user')
        
        if (token && user) {
          this.token = token
          this.user = JSON.parse(user)
        }
      }
    }
  }
})
```

#### 6.2.2 สร้าง Login Page

**สร้างไฟล์ pages/login.vue:**

```vue
<!-- pages/login.vue -->
<template>
  <div class="min-h-screen flex items-center justify-center bg-gray-100">
    <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
      <h1 class="text-2xl font-bold mb-6 text-center">IoT System Login</h1>
      
      <form @submit.prevent="handleLogin">
        <div class="mb-4">
          <label class="block text-gray-700 text-sm font-bold mb-2">
            Username
          </label>
          <input
            v-model="username"
            type="text"
            required
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <div class="mb-6">
          <label class="block text-gray-700 text-sm font-bold mb-2">
            Password
          </label>
          <input
            v-model="password"
            type="password"
            required
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <button
          type="submit"
          class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          Login
        </button>
      </form>
      
      <div v-if="error" class="mt-4 text-red-500 text-sm text-center">
        {{ error }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useAuthStore } from '~/stores/auth'

const authStore = useAuthStore()
const username = ref('')
const password = ref('')
const error = ref('')

const handleLogin = async () => {
  error.value = ''
  const success = await authStore.login(username.value, password.value)
  
  if (success) {
    // Redirect based on role
    const role = authStore.userRole
    if (role === 'admin') {
      navigateTo('/admin/dashboard')
    } else if (role === 'user_level_1') {
      navigateTo('/dashboard')
    } else {
      navigateTo('/dashboard')
    }
  } else {
    error.value = 'Invalid username or password'
  }
}
</script>
```

## 7. MQTT & Node-RED Setup

### 7.1 ตั้งค่า MQTT Broker (Mosquitto)

#### 7.1.1 สร้าง MQTT Configuration

**สร้างไฟล์ mqtt/config/mosquitto.conf:**

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# สร้าง Directory
mkdir -p ~/iot-system/mqtt/config

# สร้างไฟล์ mosquitto.conf
cat > ~/iot-system/mqtt/config/mosquitto.conf << 'EOF'
listener 1883
allow_anonymous false
password_file /mosquitto/config/passwd
acl_file /mosquitto/config/acl

# WebSocket
listener 9001
protocol websockets

# Logging
log_dest file /mosquitto/log/mosquitto.log
log_type error
log_type warning
log_type notice
log_type information

# Persistence
persistence true
persistence_location /mosquitto/data/
EOF
```

#### 7.1.2 สร้าง Password และ ACL File

**คำสั่งสร้าง Password File:**

```bash
# สร้าง Password File (ใช้ Docker Container)
docker run -it --rm -v ~/iot-system/mqtt/config:/mosquitto/config eclipse-mosquitto mosquitto_passwd -c /mosquitto/config/passwd mqtt_user
# Password: mqtt_password

# หรือสร้างไฟล์ passwd โดยตรง (ถ้ารู้ hash)
# ใช้คำสั่ง mosquitto_passwd เพื่อสร้าง hash
```

**สร้างไฟล์ ACL:**

```bash
# สร้างไฟล์ ACL
cat > ~/iot-system/mqtt/config/acl << 'EOF'
user mqtt_user
topic read sensor/#
topic write sensor/#
topic readwrite command/#
EOF
```

#### 7.1.3 สร้าง Docker Compose สำหรับ MQTT

**สร้างไฟล์ docker-compose.mqtt.yml:**

```bash
cat > ~/iot-system/mqtt/docker-compose.mqtt.yml << 'EOF'
version: '3.8'

services:
  mqtt:
    image: eclipse-mosquitto:latest
    container_name: iot-mqtt
    restart: always
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./config/mosquitto.conf:/mosquitto/config/mosquitto.conf
      - ./config/passwd:/mosquitto/config/passwd
      - ./config/acl:/mosquitto/config/acl
      - mqtt_data:/mosquitto/data
      - mqtt_log:/mosquitto/log
    networks:
      - iot_network

volumes:
  mqtt_data:
  mqtt_log:

networks:
  iot_network:
    external: true
EOF

# สร้าง Network (ถ้ายังไม่มี)
docker network create iot_network 2>/dev/null || true

# Run MQTT Broker
cd ~/iot-system/mqtt
docker-compose -f docker-compose.mqtt.yml up -d

# ตรวจสอบ
docker ps | grep mqtt
docker logs iot-mqtt
```

**วิธีเช็ค:**

```bash
# ทดสอบ MQTT Connection (ต้องติดตั้ง mosquitto-clients หรือใช้ MQTTX)
# ติดตั้ง MQTTX CLI
npm install -g @emqx/mqttx-cli

# Subscribe
mqttx sub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/#" -v

# Publish (ใน Terminal อื่น)
mqttx pub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/temp/001" -m '{"value": 25.5}'
```

---

### 7.2 ตั้งค่า Node-RED

#### 7.2.1 สร้าง Node-RED Flow

**สร้างไฟล์ nodered/flows.json:**

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# สร้าง Directory
mkdir -p ~/iot-system/nodered

# สร้างไฟล์ flows.json
cat > ~/iot-system/nodered/flows.json << 'EOF'
[
  {
    "id": "mqtt-in-1",
    "type": "mqtt in",
    "name": "Sensor Temperature",
    "topic": "sensor/temp/#",
    "qos": "1",
    "broker": "mqtt-broker-1",
    "x": 100,
    "y": 100
  },
  {
    "id": "function-1",
    "type": "function",
    "name": "Process Data",
    "func": "const data = JSON.parse(msg.payload);\nmsg.payload = {\n    user_id: 1,\n    sensor_type: 'temperature',\n    sensor_value: parseFloat(data.value),\n    mqtt_topic: msg.topic,\n    timestamp: new Date().toISOString()\n};\nreturn msg;",
    "x": 300,
    "y": 100
  },
  {
    "id": "mysql-1",
    "type": "mysql",
    "name": "Save to Database",
    "host": "172.16.10.10",
    "port": "3306",
    "user": "iot_user",
    "password": "iot_password_123",
    "database": "iot_db",
    "sql": "INSERT INTO sensor_data (user_id, sensor_type, sensor_value, mqtt_topic, timestamp) VALUES (?, ?, ?, ?, ?)",
    "x": 500,
    "y": 100
  }
]
EOF
```

#### 7.2.2 สร้าง Docker Compose สำหรับ Node-RED

**สร้างไฟล์ docker-compose.nodered.yml:**

```bash
cat > ~/iot-system/nodered/docker-compose.nodered.yml << 'EOF'
version: '3.8'

services:
  nodered:
    image: nodered/node-red:latest
    container_name: iot-nodered
    restart: always
    ports:
      - "1880:1880"
    volumes:
      - nodered_data:/data
    environment:
      - TZ=Asia/Bangkok
    networks:
      - iot_network

volumes:
  nodered_data:

networks:
  iot_network:
    external: true
EOF

# สร้าง Network (ถ้ายังไม่มี)
docker network create iot_network 2>/dev/null || true

# Run Node-RED
cd ~/iot-system/nodered
docker-compose -f docker-compose.nodered.yml up -d

# ตรวจสอบ
docker ps | grep nodered
docker logs iot-nodered
```

**วิธีเช็ค:**

```bash
# ทดสอบ Node-RED Web UI
curl http://172.16.10.10:1880

# เปิด Browser: http://172.16.10.10:1880
```

**หมายเหตุ:** ต้องติดตั้ง node-red-node-mysql ใน Node-RED:
```bash
# เข้า Node-RED Container
docker exec -it iot-nodered npm install node-red-node-mysql

# Restart Container
docker restart iot-nodered
```

---

## 8. ESP32 Simulation (Node.js Script)

### 8.1 สร้าง Node.js Script จำลอง ESP32

#### 8.1.1 สร้าง ESP32 Simulator Script

**สร้างไฟล์ esp32-simulator/esp32-sim.js:**

```bash
# บน Windows Host (D:\Skill-PWS\)
cd D:\Skill-PWS
mkdir esp32-simulator
cd esp32-simulator

# Initialize Node.js Project
npm init -y

# ติดตั้ง Dependencies
npm install mqtt

# สร้างไฟล์ esp32-sim.js
cat > esp32-sim.js << 'EOF'
// esp32-sim.js - ESP32 Simulator using Node.js
const mqtt = require('mqtt');

// MQTT Broker Configuration
const mqttConfig = {
  host: '172.16.10.10',
  port: 1883,
  username: 'mqtt_user',
  password: 'mqtt_password',
  clientId: 'ESP32_Simulator_001'
};

// MQTT Topics
const topics = {
  temp: 'sensor/temp/001',
  humidity: 'sensor/humidity/001',
  command: 'command/device001/#'
};

// Connect to MQTT Broker
const client = mqtt.connect(`mqtt://${mqttConfig.host}:${mqttConfig.port}`, {
  username: mqttConfig.username,
  password: mqttConfig.password,
  clientId: mqttConfig.clientId
});

// Connection Events
client.on('connect', () => {
  console.log('✅ Connected to MQTT Broker');
  console.log(`   Host: ${mqttConfig.host}:${mqttConfig.port}`);
  console.log(`   Client ID: ${mqttConfig.clientId}`);
  
  // Subscribe to command topic
  client.subscribe(topics.command, (err) => {
    if (err) {
      console.error('❌ Subscribe error:', err);
    } else {
      console.log(`✅ Subscribed to: ${topics.command}`);
    }
  });
});

client.on('error', (error) => {
  console.error('❌ MQTT Error:', error);
});

client.on('close', () => {
  console.log('⚠️  MQTT Connection closed');
});

// Message Handler (for commands)
client.on('message', (topic, message) => {
  const payload = message.toString();
  console.log(`📨 Received command: ${topic} = ${payload}`);
  
  if (topic === 'command/device001/on') {
    console.log('💡 Device ON');
  } else if (topic === 'command/device001/off') {
    console.log('💡 Device OFF');
  }
});

// Simulate Sensor Data
function simulateSensorData() {
  // Simulate Temperature (20-30°C)
  const temperature = (20 + Math.random() * 10).toFixed(2);
  
  // Simulate Humidity (40-80%)
  const humidity = (40 + Math.random() * 40).toFixed(2);
  
  // Publish Temperature
  const tempPayload = JSON.stringify({ value: parseFloat(temperature) });
  client.publish(topics.temp, tempPayload, { qos: 1 }, (err) => {
    if (err) {
      console.error('❌ Publish error (temp):', err);
    } else {
      console.log(`📤 Published: ${topics.temp} = ${tempPayload}`);
    }
  });
  
  // Publish Humidity
  const humidityPayload = JSON.stringify({ value: parseFloat(humidity) });
  client.publish(topics.humidity, humidityPayload, { qos: 1 }, (err) => {
    if (err) {
      console.error('❌ Publish error (humidity):', err);
    } else {
      console.log(`📤 Published: ${topics.humidity} = ${humidityPayload}`);
    }
  });
}

// Start Simulation
console.log('🚀 ESP32 Simulator Starting...');
console.log('   Simulating DHT22 Sensor (Temperature & Humidity)');
console.log('   Publishing every 5 seconds...\n');

// Publish sensor data every 5 seconds
setInterval(simulateSensorData, 5000);

// Initial publish
setTimeout(simulateSensorData, 2000);

// Graceful Shutdown
process.on('SIGINT', () => {
  console.log('\n🛑 Shutting down ESP32 Simulator...');
  client.end();
  process.exit(0);
});
EOF
```

#### 8.1.2 สร้าง package.json

**แก้ไขไฟล์ package.json:**

```json
{
  "name": "esp32-simulator",
  "version": "1.0.0",
  "description": "ESP32 Simulator using Node.js and MQTT",
  "main": "esp32-sim.js",
  "scripts": {
    "start": "node esp32-sim.js",
    "dev": "node esp32-sim.js"
  },
  "keywords": ["esp32", "mqtt", "simulator", "iot"],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "mqtt": "^5.3.0"
  }
}
```

#### 8.1.3 วิธีใช้งาน ESP32 Simulator

**คำสั่งรัน:**

```bash
# บน Windows Host (D:\Skill-PWS\esp32-simulator\)
cd D:\Skill-PWS\esp32-simulator

# ติดตั้ง Dependencies
npm install

# รัน Simulator
npm start
```

**Output ตัวอย่าง:**

```
🚀 ESP32 Simulator Starting...
   Simulating DHT22 Sensor (Temperature & Humidity)
   Publishing every 5 seconds...

✅ Connected to MQTT Broker
   Host: 172.16.10.10:1883
   Client ID: ESP32_Simulator_001
✅ Subscribed to: command/device001/#
📤 Published: sensor/temp/001 = {"value":25.34}
📤 Published: sensor/humidity/001 = {"value":62.18}
📤 Published: sensor/temp/001 = {"value":24.87}
📤 Published: sensor/humidity/001 = {"value":58.92}
...
```

**ทดสอบ Command:**

```bash
# ใน Terminal อื่น (ต้องติดตั้ง MQTTX CLI)
mqttx pub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "command/device001/on" -m "1"
mqttx pub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "command/device001/off" -m "0"
```

---

## 9. Docker Compose Configuration

### 9.1 สร้าง docker-compose.yml

#### 9.1.1 โครงสร้างไฟล์

**โครงสร้างโฟลเดอร์:**

```
D:\Skill-PWS\
├─ docker-compose.yml
├─ docker-compose.dev.yml
├─ dev.env
├─ prod.env
├─ backend\
│   ├─ Dockerfile
│   ├─ package.json
│   └─ ...
├─ frontend\
│   ├─ Dockerfile
│   ├─ package.json
│   └─ ...
└─ mqtt\
    └─ config\
        ├─ mosquitto.conf
        ├─ passwd
        └─ acl
```

**หมายเหตุ:** สำหรับ Notebook Implementation, Backend และ Frontend จะรันบน Windows Host โดยตรง ไม่ใช้ Docker (เพื่อความง่ายในการพัฒนา)

#### 9.1.2 สร้างไฟล์ docker-compose.yml (สำหรับ Production Server)

**สร้างไฟล์บน Production Server:**

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# สร้าง Directory
mkdir -p ~/iot-system/docker
cd ~/iot-system/docker

# สร้างไฟล์ docker-compose.yml
cat > docker-compose.yml << 'EOF'
version: '3.8'

services:
  # Database Service
  db:
    image: mariadb:10.11
    container_name: iot-db
    restart: always
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword123
      - MYSQL_DATABASE=iot_db
      - MYSQL_USER=iot_user
      - MYSQL_PASSWORD=iot_password_123
    volumes:
      - db_data:/var/lib/mysql
      - ../database/init:/docker-entrypoint-initdb.d
    networks:
      - iot_network
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci

  # MQTT Broker
  mqtt:
    image: eclipse-mosquitto:latest
    container_name: iot-mqtt
    restart: always
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ../mqtt/config/mosquitto.conf:/mosquitto/config/mosquitto.conf
      - ../mqtt/config/passwd:/mosquitto/config/passwd
      - ../mqtt/config/acl:/mosquitto/config/acl
      - mqtt_data:/mosquitto/data
      - mqtt_log:/mosquitto/log
    networks:
      - iot_network

  # Node-RED
  nodered:
    image: nodered/node-red:latest
    container_name: iot-nodered
    restart: always
    ports:
      - "1880:1880"
    volumes:
      - nodered_data:/data
    environment:
      - TZ=Asia/Bangkok
    networks:
      - iot_network
    depends_on:
      - db
      - mqtt

  # phpMyAdmin (Optional - สำหรับจัดการ Database)
  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest
    container_name: iot-phpmyadmin
    restart: always
    ports:
      - "8080:80"
    environment:
      - PMA_HOST=db
      - PMA_USER=root
      - PMA_PASSWORD=rootpassword123
    depends_on:
      - db
    networks:
      - iot_network

volumes:
  db_data:
    driver: local
  nodered_data:
    driver: local
  mqtt_data:
    driver: local
  mqtt_log:
    driver: local

networks:
  iot_network:
    driver: bridge
EOF
```

#### 9.1.3 คำสั่งการใช้งาน Docker Compose

**Build และ Start Services:**

```bash
# Build และ Start ทุก Services
cd ~/iot-system/docker
docker-compose up -d

# ดู Logs
docker-compose logs -f

# ดู Status
docker-compose ps

# Stop Services
docker-compose stop

# Stop และ Remove Containers
docker-compose down

# Stop, Remove Containers และ Volumes
docker-compose down -v
```

**ตรวจสอบ Services:**

```bash
# ตรวจสอบ Containers
docker-compose ps

# ตรวจสอบ Logs
docker-compose logs db
docker-compose logs mqtt
docker-compose logs nodered

# ตรวจสอบ Network
docker network inspect iot-system_iot_network

# ตรวจสอบ Volumes
docker volume ls
```

---

## 10. Testing & Quick Reference

### 10.1 ทดสอบระบบทั้งหมด

#### 10.1.1 ทดสอบ Database

```bash
# SSH เข้า Production Server
ssh it@172.16.10.10

# เช็ค Database Connection
docker exec -it iot-db mysql -u iot_user -piot_password_123 iot_db -e "SELECT COUNT(*) as total FROM users;"

# เช็ค Sensor Data
docker exec -it iot-db mysql -u iot_user -piot_password_123 iot_db -e "SELECT * FROM sensor_data ORDER BY timestamp DESC LIMIT 5;"
```

#### 10.1.2 ทดสอบ MQTT

```bash
# บน Windows Host (ต้องติดตั้ง MQTTX CLI)
npm install -g @emqx/mqttx-cli

# Subscribe
mqttx sub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/#" -v

# Publish (ใน Terminal อื่น)
mqttx pub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/temp/001" -m '{"value": 25.5}'
```

#### 10.1.3 ทดสอบ Backend API

```bash
# บน Windows Host (Backend รันบน localhost:3000)
# Health Check
curl http://localhost:3000/api/health

# Login
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d "{\"username\":\"admin\",\"password\":\"1234\"}"

# Get Sensor Data (ต้องใช้ Token จาก Login)
curl -X GET http://localhost:3000/api/sensor-data \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"
```

#### 10.1.4 ทดสอบ Frontend

```bash
# บน Windows Host
# เปิด Browser: http://localhost:3001
# หรือ: http://172.16.10.10:3001 (ถ้า Frontend รันบน Production Server)
```

#### 10.1.5 ทดสอบ ESP32 Simulator

```bash
# บน Windows Host
cd D:\Skill-PWS\esp32-simulator
npm start

# ควรเห็นข้อมูลถูก Publish ไปยัง MQTT Broker ทุก 5 วินาที
```

#### 10.1.6 ทดสอบ Node-RED

```bash
# เปิด Browser: http://172.16.10.10:1880
# สร้าง Flow:
# 1. MQTT In node: Subscribe to "sensor/temp/#"
# 2. Function node: Process data
# 3. MySQL node: Insert to database
```

---

### 10.2 Quick Reference

#### 10.2.1 User Accounts และ Passwords

**Application Users (IoT System):**
| Username | Password | Email | Role |
|----------|----------|-------|------|
| `admin` | `1234` | admin@sisat.lan | admin |
| `user1` | `1234` | user1@sisat.lan | user_level_1 |
| `user2` | `1234` | user2@sisat.lan | user_level_2 |

**System Users (Linux VMs):**
| Hostname | Username | Password | IP Address |
|----------|----------|----------|------------|
| git.sisat.lan | `it` | `12345678` | 172.16.10.20 |
| prod.sisat.lan | `it` | `12345678` | 172.16.10.10 |

**Database Credentials:**
| Service | Username | Password | Database |
|---------|----------|----------|----------|
| MariaDB Root | `root` | `rootpassword123` | - |
| MariaDB User | `iot_user` | `iot_password_123` | iot_db |

**MQTT Credentials:**
| Username | Password |
|----------|----------|
| `mqtt_user` | `mqtt_password` |

#### 10.2.2 IP Addresses และ Network Configuration

**Virtual Machines:**
| VM Name | Hostname | IP Address | Subnet |
|---------|----------|------------|--------|
| Git Server | git.sisat.lan | 172.16.10.20 | /24 |
| Production Server | prod.sisat.lan | 172.16.10.10 | /24 |

**Network:**
- Network Type: Internal Network (VirtualBox)
- Network Name: `iot-network`
- Subnet: 172.16.10.0/24
- Gateway: (ไม่จำเป็นสำหรับ Internal Network)

#### 10.2.3 URLs และ Ports

**Web Interfaces:**
| Service | URL | Port | Protocol |
|---------|-----|------|----------|
| GitLab | http://172.16.10.20 | 80 | HTTP |
| Frontend Application | http://localhost:3001 | 3001 | HTTP |
| Node-RED | http://172.16.10.10:1880 | 1880 | HTTP |
| phpMyAdmin | http://172.16.10.10:8080 | 8080 | HTTP |

**API Endpoints:**
| Service | Base URL | Port | Protocol |
|---------|----------|------|----------|
| Backend API | http://localhost:3000/api | 3000 | HTTP |
| Health Check | http://localhost:3000/api/health | 3000 | HTTP |

**MQTT:**
| Service | Host | Port | Protocol |
|---------|------|------|----------|
| MQTT Broker | 172.16.10.10 | 1883 | MQTT |
| MQTT WebSocket | 172.16.10.10 | 9001 | WebSocket |

**Database:**
| Service | Host | Port | Protocol |
|---------|------|------|----------|
| MariaDB | 172.16.10.10 | 3306 | MySQL |

#### 10.2.4 Quick Access Commands

**SSH Access:**
```bash
# Git Server
ssh it@172.16.10.20

# Production Server
ssh it@172.16.10.10
```

**Database Access:**
```bash
# Connect to MariaDB
ssh it@172.16.10.10 "docker exec -it iot-db mysql -u iot_user -piot_password_123 iot_db"

# Connect as root
ssh it@172.16.10.10 "docker exec -it iot-db mysql -u root -prootpassword123"
```

**MQTT Test:**
```bash
# Subscribe
mqttx sub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/#" -v

# Publish
mqttx pub -h 172.16.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/temp/001" -m '{"value": 25.5}'
```

**API Test:**
```bash
# Health Check (Backend รันบน localhost:3000)
curl http://localhost:3000/api/health

# Login
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"1234"}'
```

**ESP32 Simulator:**
```bash
# บน Windows Host
cd D:\Skill-PWS\esp32-simulator
npm start
```

#### 10.2.5 Environment Variables Summary

**Backend (.env):**
```env
NODE_ENV=development
PORT=3000
JWT_SECRET=your-secret-key-change-this-in-production
JWT_EXPIRE=24h
DB_HOST=172.16.10.10
DB_PORT=3306
DB_USER=iot_user
DB_PASSWORD=iot_password_123
DB_NAME=iot_db
UPLOAD_DIR=./uploads
```

**Frontend (nuxt.config.ts):**
```typescript
apiBase: 'http://localhost:3000/api'
```

**ESP32 Simulator:**
```javascript
host: '172.16.10.10'
port: 1883
username: 'mqtt_user'
password: 'mqtt_password'
```

---

### 10.3 Todo List สำหรับการทดสอบระบบ

**ขั้นตอนการทดสอบ:**

1. ✅ **VirtualBox Setup**
   - [ ] ติดตั้ง VirtualBox 7.2
   - [ ] สร้าง VM: Git Server (172.16.10.20)
   - [ ] สร้าง VM: Production Server (172.16.10.10)
   - [ ] ตั้งค่า Network Configuration
   - [ ] ตั้งค่า Host File บน Windows

2. ✅ **DevOps Setup**
   - [ ] ติดตั้ง Docker บน Production Server
   - [ ] ติดตั้ง GitLab บน Git Server
   - [ ] ตั้งค่า GitLab Project

3. ✅ **Database Setup**
   - [ ] ติดตั้ง MariaDB ด้วย Docker
   - [ ] สร้าง Database Schema
   - [ ] เพิ่มข้อมูลเริ่มต้น (Users)

4. ✅ **Backend Implementation**
   - [ ] สร้าง Backend Project
   - [ ] ติดตั้ง Dependencies
   - [ ] สร้าง API Routes และ Controllers
   - [ ] ทดสอบ Backend API

5. ✅ **Frontend Implementation**
   - [ ] สร้าง Frontend Project (Nuxt 3)
   - [ ] ติดตั้ง Dependencies
   - [ ] สร้าง Authentication
   - [ ] สร้าง Login Page
   - [ ] ทดสอบ Frontend

6. ✅ **MQTT & Node-RED Setup**
   - [ ] ตั้งค่า MQTT Broker (Mosquitto)
   - [ ] สร้าง Password และ ACL File
   - [ ] ตั้งค่า Node-RED
   - [ ] ทดสอบ MQTT Connection
   - [ ] ทดสอบ Node-RED Flow

7. ✅ **ESP32 Simulation**
   - [ ] สร้าง ESP32 Simulator Script
   - [ ] ติดตั้ง Dependencies
   - [ ] ทดสอบ ESP32 Simulator
   - [ ] ตรวจสอบข้อมูลถูกส่งไปยัง MQTT Broker

8. ✅ **Docker Compose**
   - [ ] สร้าง docker-compose.yml
   - [ ] Build และ Start Services
   - [ ] ตรวจสอบ Services Status
   - [ ] ทดสอบ Connectivity

9. ✅ **System Testing**
   - [ ] ทดสอบ Database
   - [ ] ทดสอบ MQTT
   - [ ] ทดสอบ Backend API
   - [ ] ทดสอบ Frontend
   - [ ] ทดสอบ ESP32 Simulator
   - [ ] ทดสอบ Node-RED Flow
   - [ ] ทดสอบ End-to-End Flow

10. ✅ **Documentation**
    - [ ] ตรวจสอบความถูกต้องของ Documentation
    - [ ] อัปเดต Quick Reference
    - [ ] สร้าง Troubleshooting Guide

---

**หมายเหตุ:** 
- เปลี่ยน passwords ทั้งหมดใน production environment
- ใช้ strong passwords สำหรับ production
- เก็บ credentials ไว้ใน secure location
- ไม่ commit `.env` files ที่มี sensitive data ลง Git

---

**สิ้นสุด Notebook Implementation Phase**