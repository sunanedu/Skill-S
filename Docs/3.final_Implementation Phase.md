# Implementation Phase - IoT System with MQTT, Node-RED, ESP32

## 1. บทนำ (Introduction)

### 1.1 ความหมาย/การใช้งาน/คืออะไร
Implementation Phase เป็นขั้นตอนการพัฒนาระบบจริงตาม Design Phase ที่ได้ออกแบบไว้ โดยครอบคลุมการติดตั้ง ตั้งค่า และพัฒนา Component ต่างๆ ของระบบทั้งหมด

### 1.2 วัตถุประสงค์
- พัฒนาระบบให้สอดคล้องกับ Design Phase
- ใช้เวลาน้อยที่สุด ง่ายที่สุด เพื่อให้ทำได้ภายใน 24 ชั่วโมง
- เน้นการทำงานที่จำเป็นและให้คะแนนสูงสุด
- มีคำสั่งและโค้ดที่พร้อมใช้งานจริง

### 1.3 โครงสร้างการพัฒนา
1. **Network Setup** - ตั้งค่า Router, Switch, VLAN
2. **Virtualization** - ติดตั้ง Proxmox และสร้าง VMs
3. **DevOps** - ติดตั้ง Docker, GitLab, CI/CD
4. **Database** - สร้าง Database Schema และ Data
5. **Backend** - พัฒนา Node.js API
6. **Frontend** - พัฒนา Vue 3 + Nuxt 3
7. **MQTT & Node-RED** - ตั้งค่า MQTT Broker และ Node-RED
8. **ESP32** - เขียนโค้ด Arduino สำหรับ ESP32
9. **Docker Compose** - สร้าง docker-compose.yml
10. **Testing** - ทดสอบระบบทั้งหมด

---

## 2. Network Setup และ Configuration

### 2.1 ตั้งค่า Router TP-LINK Archer AX10

#### 2.1.1 ตั้งค่า Router ตัวหลัก

**ขั้นตอนการทำ:**

1. **เชื่อมต่อ Router:**
   - เชื่อมต่อ Router กับคอมพิวเตอร์ผ่าน Ethernet Cable
   - เปิด Browser ไปที่ `http://192.168.1.1` หรือ `http://tplinkwifi.net`
   - Login ด้วย Username/Password เริ่มต้น (admin/admin)

2. **ตั้งค่า Network:**
   ```
   - LAN IP: 192.168.100.1
   - Subnet Mask: 255.255.255.0
   - DHCP Server: Enable
   - DHCP Range: 192.168.100.30-50
   - Gateway: 192.168.100.1
   ```

3. **ตั้งค่า Wireless:**
   ```
   - SSID: @iot
   - Password: 12345678
   - Security: WPA2-PSK
   - Channel: Auto
   ```

4. **ตั้งค่า NAT:**
   - ไปที่ Advanced > NAT
   - เปิดใช้งาน NAT/PAT
   - ตั้งค่า WAN Interface

**วิธีเช็ค:**
```bash
# ทดสอบ Router Connectivity
ping 192.168.100.1

# ทดสอบ DHCP
# บน Windows: ipconfig /release && ipconfig /renew
# บน Linux: dhclient -r && dhclient
```

---

### 2.2 ตั้งค่า L2 Managed Switch (HP JG920A 1920-8G)

#### 2.2.1 เข้าสู่ Switch

**ขั้นตอนการทำ:**

1. **เชื่อมต่อ Switch:**
   - เชื่อมต่อ Switch กับคอมพิวเตอร์ผ่าน Console Port หรือ Ethernet Port
   - Default IP: 192.168.1.1 หรือ 192.168.0.1

2. **เข้าสู่ Switch:**
   ```bash
   # ผ่าน Console (ใช้ PuTTY หรือ Terminal)
   # Serial Settings: 9600, 8, N, 1
   
   # ผ่าน Web Interface
   # เปิด Browser: http://192.168.1.1
   # Default Username: admin, Password: (ว่างเปล่า)
   ```

#### 2.2.2 ตั้งค่า VLAN

**คำสั่งตั้งค่า VLAN:**

```bash
# เข้าสู่ Switch Configuration Mode
enable
configure terminal

# สร้าง VLAN 10 (Server/IoT)
vlan 10
 name Server-IoT
 exit

# สร้าง VLAN 20 (Development)
vlan 20
 name Development
 exit

# ตั้งค่า Port 1 เป็น Trunk (เชื่อมต่อ Router)
interface gigabitethernet 1/0/1
 port link-type trunk
 port trunk permit vlan 10 20
 exit

# ตั้งค่า Port 2 เป็น Access VLAN 10 (VM Server)
interface gigabitethernet 1/0/2
 port link-type access
 port access vlan 10
 exit

# ตั้งค่า Port 3 เป็น Access VLAN 10 (Access Point)
interface gigabitethernet 1/0/3
 port link-type access
 port access vlan 10
 exit

# ตั้งค่า Port 4-5 เป็น Access VLAN 20 (Development PCs)
interface range gigabitethernet 1/0/4 to 1/0/5
 port link-type access
 port access vlan 20
 exit

# บันทึกการตั้งค่า
write memory
exit
```

**วิธีเช็ค:**
```bash
# ดู VLAN ทั้งหมด
show vlan

# ดู Port Configuration
show interface brief

# ดู VLAN Membership
show vlan id 10
show vlan id 20
```

#### 2.2.3 ตั้งค่า DHCP Snooping

**คำสั่งตั้งค่า DHCP Snooping:**

```bash
# เข้าสู่ Switch Configuration Mode
enable
configure terminal

# เปิดใช้งาน DHCP Snooping
dhcp-snooping enable

# ตั้งค่า Trusted Port (Port ที่เชื่อมต่อ Router/DHCP Server)
dhcp-snooping trusted interface gigabitethernet 1/0/1

# ตั้งค่า DHCP Snooping สำหรับ VLAN
dhcp-snooping vlan 10
dhcp-snooping vlan 20

# บันทึกการตั้งค่า
write memory
exit
```

**วิธีเช็ค:**
```bash
# ดู DHCP Snooping Status
show dhcp-snooping

# ดู DHCP Snooping Binding Table
show dhcp-snooping binding
```

---

### 2.3 ตั้งค่า Router TP-LINK ตัวที่ 2 (Access Point Mode)

#### 2.3.1 ตั้งค่า Access Point

**ขั้นตอนการทำ:**

1. **เชื่อมต่อ Router ตัวที่ 2:**
   - เชื่อมต่อ Router ตัวที่ 2 กับ Switch Port 3 (VLAN 10)
   - เปิด Browser ไปที่ IP Address ของ Router ตัวที่ 2

2. **ตั้งค่า Access Point Mode:**
   - ไปที่ Advanced > Operation Mode
   - เลือก "Access Point Mode"
   - ตั้งค่า IP Address: 192.168.10.3 (Static IP ใน VLAN 10)
   - Gateway: 192.168.10.1

3. **ตั้งค่า Wireless:**
   ```
   - SSID: @wifi
   - Password: 12345678
   - Security: WPA2-PSK
   - Channel: Auto
   ```

**วิธีเช็ค:**
```bash
# ทดสอบ Access Point Connectivity
ping 192.168.10.3

# ทดสอบ Wireless Connection
# เชื่อมต่อ ESP32 หรือ Device อื่นๆ กับ SSID: @wifi
```

---

## 3. Virtualization Setup (Proxmox)

### 3.1 ติดตั้ง Proxmox

#### 3.1.1 Download และติดตั้ง Proxmox

**ขั้นตอนการทำ:**

1. **Download Proxmox ISO:**
   - ไปที่ https://www.proxmox.com/en/downloads
   - Download Proxmox VE ISO (เวอร์ชันล่าสุด)

2. **สร้าง Bootable USB:**
   ```bash
   # ใช้ Rufus (Windows) หรือ dd (Linux)
   # Rufus: เลือก ISO และ Flash
   # Linux: dd if=proxmox.iso of=/dev/sdX bs=4M
   ```

3. **ติดตั้ง Proxmox:**
   - Boot จาก USB
   - ติดตั้งตาม Wizard
   - ตั้งค่า:
     - Hostname: proxmox.sisat.lan
     - IP Address: 192.168.10.5 (Static IP ใน VLAN 10)
     - Gateway: 192.168.10.1
     - DNS: 8.8.8.8

4. **เข้าสู่ Proxmox Web UI:**
   - เปิด Browser: https://192.168.10.5:8006
   - Login ด้วย root และ password ที่ตั้งไว้

**วิธีเช็ค:**
```bash
# เช็ค Proxmox Status
systemctl status pve-cluster

# เช็ค Network
ip addr show
ping 192.168.10.1
```

---

### 3.2 สร้าง Virtual Machines

#### 3.2.1 สร้าง VM1: Git Server

**ขั้นตอนการทำ:**

1. **Download Ubuntu 24.04 LTS Server ISO:**
   - ไปที่ https://ubuntu.com/download/server
   - Download Ubuntu 24.04 LTS Server ISO

2. **สร้าง VM ใน Proxmox:**
   - คลิก "Create VM"
   - General:
     - VM ID: 100
     - Name: git-server
   - OS:
     - Use CD/DVD disc image file (iso)
     - เลือก Ubuntu 24.04 LTS Server ISO
   - System:
     - Graphic Card: Default
     - Qemu Agent: Enable
   - Hard Disk:
     - Disk size: 20GB
     - Storage: local-lvm
   - CPU:
     - Sockets: 1
     - Cores: 2
   - Memory:
     - RAM: 4096 MB
   - Network:
     - Bridge: vmbr0
     - Model: VirtIO

3. **ติดตั้ง Ubuntu:**
   - Start VM และติดตั้ง Ubuntu
   - ตั้งค่า:
     - Hostname: git.sisat.lan
     - User: it
     - Password: 12345678
     - Static IP: 192.168.10.20/24
     - Gateway: 192.168.10.1
     - DNS: 8.8.8.8

**วิธีเช็ค:**
```bash
# SSH เข้า VM
ssh it@192.168.10.20

# เช็ค Network
ip addr show
ping 192.168.10.1
ping 8.8.8.8
```

#### 3.2.2 สร้าง VM2: Production Server

**ขั้นตอนการทำ:**

1. **สร้าง VM ใน Proxmox:**
   - คลิก "Create VM"
   - General:
     - VM ID: 101
     - Name: production-server
   - OS:
     - Use CD/DVD disc image file (iso)
     - เลือก Ubuntu 24.04 LTS Server ISO
   - System:
     - Graphic Card: Default
     - Qemu Agent: Enable
   - Hard Disk:
     - Disk size: 30GB
     - Storage: local-lvm
   - CPU:
     - Sockets: 1
     - Cores: 2
   - Memory:
     - RAM: 4096 MB
   - Network:
     - Bridge: vmbr0
     - Model: VirtIO

2. **ติดตั้ง Ubuntu:**
   - Start VM และติดตั้ง Ubuntu
   - ตั้งค่า:
     - Hostname: iot.sisat.lan
     - User: it
     - Password: 12345678
     - Static IP: 192.168.10.10/24
     - Gateway: 192.168.10.1
     - DNS: 8.8.8.8

**วิธีเช็ค:**
```bash
# SSH เข้า VM
ssh it@192.168.10.10

# เช็ค Network
ip addr show
ping 192.168.10.1
ping 8.8.8.8
```

---

## 4. DevOps Setup

### 4.1 ติดตั้ง Docker บน Production Server

#### 4.1.1 ติดตั้ง Docker

**คำสั่งติดตั้ง Docker:**

```bash
# SSH เข้า Production Server
ssh it@192.168.10.10

# Update System
sudo apt update
sudo apt upgrade -y

# ติดตั้ง Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# เพิ่ม User เข้า Docker Group
sudo usermod -aG docker it

# ติดตั้ง Docker Compose
sudo apt install docker-compose -y

# Restart เพื่อให้ Docker Group มีผล
# Logout และ Login ใหม่ หรือ
newgrp docker

# ตรวจสอบ Docker
docker --version
docker-compose --version
```

**วิธีเช็ค:**
```bash
# ทดสอบ Docker
docker run hello-world

# ดู Docker Status
sudo systemctl status docker
```

---

### 4.2 ติดตั้ง GitLab บน Git Server

#### 4.2.1 ติดตั้ง GitLab ด้วย Docker

**คำสั่งติดตั้ง GitLab:**

```bash
# SSH เข้า Git Server
ssh it@192.168.10.20

# ติดตั้ง Docker (ทำเหมือน Production Server)
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker it
newgrp docker

# สร้าง Directory สำหรับ GitLab
sudo mkdir -p /opt/gitlab/{config,logs,data}

# Run GitLab Container
sudo docker run -d \
  --hostname git.sisat.lan \
  --name gitlab \
  --restart always \
  -p 80:80 \
  -p 443:443 \
  -p 22:22 \
  -v /opt/gitlab/config:/etc/gitlab \
  -v /opt/gitlab/logs:/var/log/gitlab \
  -v /opt/gitlab/data:/var/opt/gitlab \
  gitlab/gitlab-ce:latest

# รอให้ GitLab Start (ใช้เวลาประมาณ 5-10 นาที)
sudo docker logs -f gitlab
```

**วิธีเช็ค:**
```bash
# ดู GitLab Status
sudo docker ps | grep gitlab

# ดู GitLab Logs
sudo docker logs gitlab

# ดู Root Password
sudo docker exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password

# ทดสอบ GitLab Web UI
curl http://192.168.10.20
```

#### 4.2.2 ตั้งค่า GitLab

**ขั้นตอนการทำ:**

1. **เข้าสู่ GitLab:**
   - เปิด Browser: http://192.168.10.20
   - Login ด้วย root และ password จาก initial_root_password

2. **ตั้งค่า Root Password:**
   - เปลี่ยน Root Password เป็น password ที่ต้องการ

3. **สร้าง Project:**
   - คลิก "New Project"
   - เลือก "Create blank project"
   - Project name: iot-system
   - Visibility: Private

---

### 4.3 ติดตั้ง GitLab Runner

#### 4.3.1 ติดตั้ง GitLab Runner

**คำสั่งติดตั้ง GitLab Runner:**

```bash
# SSH เข้า Git Server
ssh it@192.168.10.20

# ติดตั้ง GitLab Runner
sudo docker run -d --name gitlab-runner \
  --restart always \
  -v /opt/gitlab-runner/config:/etc/gitlab-runner \
  -v /var/run/docker.sock:/var/run/docker.sock \
  gitlab/gitlab-runner:latest

# Register Runner
sudo docker exec -it gitlab-runner gitlab-runner register
```

**ขั้นตอน Register Runner:**

1. **Get Registration Token:**
   - ไปที่ GitLab > Settings > CI/CD > Runners
   - Copy Registration Token

2. **Register Runner:**
   ```
   Enter the GitLab instance URL: http://192.168.10.20
   Enter the registration token: [Paste Token]
   Enter a description: docker-runner
   Enter tags: docker
   Enter executor: docker
   Enter default Docker image: docker:latest
   ```

**วิธีเช็ค:**
```bash
# ดู Runner Status
sudo docker exec -it gitlab-runner gitlab-runner list

# ดู Runner Logs
sudo docker logs gitlab-runner
```

---

## 5. Database Setup

### 5.1 ติดตั้ง MariaDB ด้วย Docker

#### 5.1.1 สร้าง Docker Compose สำหรับ Database

**สร้างไฟล์ docker-compose.db.yml:**

```bash
# SSH เข้า Production Server
ssh it@192.168.10.10

# สร้าง Directory
mkdir -p ~/iot-system/database
cd ~/iot-system/database

# สร้างไฟล์ docker-compose.db.yml
cat > docker-compose.db.yml << 'EOF'
version: '3.8'

services:
  db:
    image: mariadb:10.11
    container_name: mariadb
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword123
      MYSQL_DATABASE: iot_db
      MYSQL_USER: iot_user
      MYSQL_PASSWORD: iot_password_123
    ports:
      - "3306:3306"
    volumes:
      - db_data:/var/lib/mysql
    networks:
      - iot_network

volumes:
  db_data:

networks:
  iot_network:
    driver: bridge
EOF

# Run Database
docker-compose -f docker-compose.db.yml up -d

# ตรวจสอบ
docker ps | grep mariadb
```

**วิธีเช็ค:**
```bash
# เช็ค Database Connection
docker exec -it mariadb mysql -u root -prootpassword123 -e "SHOW DATABASES;"

# เช็ค User
docker exec -it mariadb mysql -u root -prootpassword123 -e "SELECT User, Host FROM mysql.user;"
```

---

### 5.2 สร้าง Database Schema

#### 5.2.1 สร้าง Schema และ Tables

**สร้างไฟล์ schema.sql:**

```bash
# สร้างไฟล์ schema.sql
cat > schema.sql << 'EOF'
-- สร้าง Database
CREATE DATABASE IF NOT EXISTS iot_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

USE iot_db;

-- ตาราง users
CREATE TABLE IF NOT EXISTS users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    role ENUM('admin', 'user_level_1', 'user_level_2') NOT NULL DEFAULT 'user_level_2',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ตาราง sensor_data
CREATE TABLE IF NOT EXISTS sensor_data (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    sensor_type VARCHAR(50) NOT NULL,
    sensor_value DECIMAL(10,2) NOT NULL,
    mqtt_topic VARCHAR(255) NOT NULL,
    timestamp DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_timestamp (timestamp),
    INDEX idx_sensor_type (sensor_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ตาราง device_config
CREATE TABLE IF NOT EXISTS device_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    sensor_data_id INT,
    device_name VARCHAR(100) NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    mqtt_topic VARCHAR(255) NOT NULL,
    status ENUM('active', 'inactive', 'maintenance') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (sensor_data_id) REFERENCES sensor_data(id) ON DELETE SET NULL,
    INDEX idx_device_name (device_name),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
EOF

# Execute SQL
docker exec -i mariadb mysql -u root -prootpassword123 < schema.sql
```

**วิธีเช็ค:**
```bash
# เช็ค Tables
docker exec -it mariadb mysql -u iot_user -piot_password_123 iot_db -e "SHOW TABLES;"

# เช็ค Table Structure
docker exec -it mariadb mysql -u iot_user -piot_password_123 iot_db -e "DESCRIBE users;"
```

---

### 5.3 เพิ่มข้อมูลเริ่มต้น

#### 5.3.1 Hash Password และเพิ่ม Users

**สร้างไฟล์ hash-password.js:**

```bash
# สร้างไฟล์ hash-password.js
cat > hash-password.js << 'EOF'
const bcrypt = require('bcrypt');

const passwords = ['admin', 'user1', 'user2'];

passwords.forEach(async (password) => {
    const hash = await bcrypt.hash(password, 10);
    console.log(`Password: ${password}`);
    console.log(`Hash: ${hash}`);
    console.log('---');
});
EOF

# ติดตั้ง bcrypt
npm init -y
npm install bcrypt

# Run Script
node hash-password.js
```

**สร้างไฟล์ seed-data.sql:**

```bash
# สร้างไฟล์ seed-data.sql (ใช้ Hash จาก hash-password.js)
cat > seed-data.sql << 'EOF'
USE iot_db;

-- เพิ่ม Admin User (Password: admin)
-- ใช้ Hash จาก hash-password.js
INSERT INTO users (username, password, email, role) VALUES
('admin', '$2b$10$rOzJqZqZqZqZqZqZqZqZqO', 'admin@sisat.lan', 'admin');

-- เพิ่ม User Level 1 (Password: user1)
INSERT INTO users (username, password, email, role) VALUES
('user1', '$2b$10$rOzJqZqZqZqZqZqZqZqZqO', 'user1@sisat.lan', 'user_level_1');

-- เพิ่ม User Level 2 (Password: user2)
INSERT INTO users (username, password, email, role) VALUES
('user2', '$2b$10$rOzJqZqZqZqZqZqZqZqZqO', 'user2@sisat.lan', 'user_level_2');
EOF

# Execute SQL
docker exec -i mariadb mysql -u root -prootpassword123 < seed-data.sql
```

**วิธีเช็ค:**
```bash
# เช็ค Users
docker exec -it mariadb mysql -u iot_user -piot_password_123 iot_db -e "SELECT id, username, email, role FROM users;"
```

---

## 6. Backend Implementation

### 6.1 สร้าง Backend Project

#### 6.1.1 สร้างโครงสร้าง Project

**คำสั่งสร้าง Project:**

```bash
# บน Development PC (Windows)
cd D:\Skill-PWS
mkdir backend
cd backend

# Initialize Node.js Project
npm init -y

# ติดตั้ง Dependencies
npm install express cors dotenv jsonwebtoken bcrypt express-validator multer mysql2

# ติดตั้ง Dev Dependencies
npm install --save-dev nodemon
```

**โครงสร้างไฟล์:**
```
backend/
├─ package.json
├─ .env
├─ server.js
├─ config/
│   └─ database.js
├─ routes/
│   ├─ auth.js
│   ├─ users.js
│   ├─ sensorData.js
│   └─ devices.js
├─ controllers/
│   ├─ authController.js
│   ├─ userController.js
│   ├─ sensorDataController.js
│   └─ deviceController.js
├─ middleware/
│   ├─ auth.js
│   └─ errorHandler.js
└─ utils/
    └─ hashPassword.js
```

---

### 6.2 สร้างไฟล์ Backend

#### 6.2.1 สร้างไฟล์ server.js

**สร้างไฟล์ server.js:**

```javascript
// server.js
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const sensorDataRoutes = require('./routes/sensorData');
const deviceRoutes = require('./routes/devices');
const errorHandler = require('./middleware/errorHandler');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/sensor-data', sensorDataRoutes);
app.use('/api/devices', deviceRoutes);

// Health Check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'Server is running' });
});

// Error Handler
app.use(errorHandler);

// Start Server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

#### 6.2.2 สร้างไฟล์ config/database.js

**สร้างไฟล์ config/database.js:**

```javascript
// config/database.js
const mysql = require('mysql2/promise');
const dotenv = require('dotenv');

dotenv.config();

const pool = mysql.createPool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 3306,
  user: process.env.DB_USER || 'iot_user',
  password: process.env.DB_PASSWORD || 'iot_password_123',
  database: process.env.DB_NAME || 'iot_db',
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

module.exports = pool;
```

#### 6.2.3 สร้างไฟล์ .env

**สร้างไฟล์ .env:**

```bash
# .env
NODE_ENV=development
PORT=3000
JWT_SECRET=your-secret-key-change-this-in-production
JWT_EXPIRE=24h

DB_HOST=192.168.10.10
DB_PORT=3306
DB_USER=iot_user
DB_PASSWORD=iot_password_123
DB_NAME=iot_db

UPLOAD_DIR=./uploads
```

---

### 6.3 สร้าง Authentication

#### 6.3.1 สร้างไฟล์ middleware/auth.js

**สร้างไฟล์ middleware/auth.js:**

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');
const dotenv = require('dotenv');

dotenv.config();

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({
      status: 'error',
      message: 'Access token required'
    });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(403).json({
        status: 'error',
        message: 'Invalid or expired token'
      });
    }
    req.user = decoded;
    next();
  });
};

const isAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({
      status: 'error',
      message: 'Access denied. Admin only.'
    });
  }
  next();
};

const canWrite = (req, res, next) => {
  if (req.user.role === 'user_level_2') {
    return res.status(403).json({
      status: 'error',
      message: 'Read-only access. Cannot modify data.'
    });
  }
  next();
};

module.exports = {
  authenticateToken,
  isAdmin,
  canWrite
};
```

#### 6.3.2 สร้างไฟล์ routes/auth.js

**สร้างไฟล์ routes/auth.js:**

```javascript
// routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

router.post('/login', authController.login);
router.post('/logout', authController.logout);
router.get('/me', authController.getMe);

module.exports = router;
```

#### 6.3.3 สร้างไฟล์ controllers/authController.js

**สร้างไฟล์ controllers/authController.js:**

```javascript
// controllers/authController.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const pool = require('../config/database');
const dotenv = require('dotenv');

dotenv.config();

const login = async (req, res, next) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({
        status: 'error',
        message: 'Username and password are required'
      });
    }

    // Query User
    const [users] = await pool.execute(
      'SELECT * FROM users WHERE username = ?',
      [username]
    );

    if (users.length === 0) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid username or password'
      });
    }

    const user = users[0];

    // Verify Password
    const isValid = await bcrypt.compare(password, user.password);

    if (!isValid) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid username or password'
      });
    }

    // Generate JWT Token
    const token = jwt.sign(
      {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      process.env.JWT_SECRET,
      { expiresIn: process.env.JWT_EXPIRE || '24h' }
    );

    res.json({
      status: 'success',
      message: 'Login successful',
      data: {
        token,
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          role: user.role
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

const logout = (req, res) => {
  res.json({
    status: 'success',
    message: 'Logout successful'
  });
};

const getMe = async (req, res, next) => {
  try {
    const userId = req.user.id;

    const [users] = await pool.execute(
      'SELECT id, username, email, role, created_at FROM users WHERE id = ?',
      [userId]
    );

    if (users.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      });
    }

    res.json({
      status: 'success',
      data: users[0]
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  login,
  logout,
  getMe
};
```

---

### 6.4 สร้าง API Routes

#### 6.4.1 สร้างไฟล์ routes/sensorData.js

**สร้างไฟล์ routes/sensorData.js:**

```javascript
// routes/sensorData.js
const express = require('express');
const router = express.Router();
const sensorDataController = require('../controllers/sensorDataController');
const { authenticateToken, canWrite } = require('../middleware/auth');

router.get('/', authenticateToken, sensorDataController.getAll);
router.get('/:id', authenticateToken, sensorDataController.getById);
router.post('/', authenticateToken, canWrite, sensorDataController.create);
router.put('/:id', authenticateToken, canWrite, sensorDataController.update);
router.delete('/:id', authenticateToken, canWrite, sensorDataController.delete);

module.exports = router;
```

#### 6.4.2 สร้างไฟล์ controllers/sensorDataController.js

**สร้างไฟล์ controllers/sensorDataController.js:**

```javascript
// controllers/sensorDataController.js
const pool = require('../config/database');

const getAll = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const role = req.user.role;
    const { page = 1, limit = 10, sensor_type } = req.query;

    let query = 'SELECT * FROM sensor_data WHERE 1=1';
    const params = [];

    // Filter by user_id if not admin
    if (role !== 'admin') {
      query += ' AND user_id = ?';
      params.push(userId);
    }

    // Filter by sensor_type
    if (sensor_type) {
      query += ' AND sensor_type = ?';
      params.push(sensor_type);
    }

    query += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';
    const offset = (page - 1) * limit;
    params.push(parseInt(limit), offset);

    const [data] = await pool.execute(query, params);

    // Get total count
    let countQuery = 'SELECT COUNT(*) as total FROM sensor_data WHERE 1=1';
    const countParams = [];
    if (role !== 'admin') {
      countQuery += ' AND user_id = ?';
      countParams.push(userId);
    }
    if (sensor_type) {
      countQuery += ' AND sensor_type = ?';
      countParams.push(sensor_type);
    }

    const [countResult] = await pool.execute(countQuery, countParams);
    const total = countResult[0].total;

    res.json({
      status: 'success',
      message: 'Sensor data retrieved successfully',
      data: {
        items: data,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          totalPages: Math.ceil(total / limit)
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

const getById = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const role = req.user.role;

    let query = 'SELECT * FROM sensor_data WHERE id = ?';
    const params = [id];

    if (role !== 'admin') {
      query += ' AND user_id = ?';
      params.push(userId);
    }

    const [data] = await pool.execute(query, params);

    if (data.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Sensor data not found'
      });
    }

    res.json({
      status: 'success',
      data: data[0]
    });
  } catch (error) {
    next(error);
  }
};

const create = async (req, res, next) => {
  try {
    const { sensor_type, sensor_value, mqtt_topic, timestamp } = req.body;
    const userId = req.user.id;

    if (!sensor_type || sensor_value === undefined || !mqtt_topic) {
      return res.status(400).json({
        status: 'error',
        message: 'sensor_type, sensor_value, and mqtt_topic are required'
      });
    }

    const [result] = await pool.execute(
      'INSERT INTO sensor_data (user_id, sensor_type, sensor_value, mqtt_topic, timestamp) VALUES (?, ?, ?, ?, ?)',
      [userId, sensor_type, sensor_value, mqtt_topic, timestamp || new Date()]
    );

    const [newData] = await pool.execute(
      'SELECT * FROM sensor_data WHERE id = ?',
      [result.insertId]
    );

    res.status(201).json({
      status: 'success',
      message: 'Sensor data created successfully',
      data: newData[0]
    });
  } catch (error) {
    next(error);
  }
};

const update = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { sensor_type, sensor_value, mqtt_topic, timestamp } = req.body;
    const userId = req.user.id;
    const role = req.user.role;

    // Check if data exists and user has permission
    let checkQuery = 'SELECT * FROM sensor_data WHERE id = ?';
    const checkParams = [id];
    if (role !== 'admin') {
      checkQuery += ' AND user_id = ?';
      checkParams.push(userId);
    }

    const [existing] = await pool.execute(checkQuery, checkParams);

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Sensor data not found'
      });
    }

    // Update
    const updateFields = [];
    const updateParams = [];

    if (sensor_type) {
      updateFields.push('sensor_type = ?');
      updateParams.push(sensor_type);
    }
    if (sensor_value !== undefined) {
      updateFields.push('sensor_value = ?');
      updateParams.push(sensor_value);
    }
    if (mqtt_topic) {
      updateFields.push('mqtt_topic = ?');
      updateParams.push(mqtt_topic);
    }
    if (timestamp) {
      updateFields.push('timestamp = ?');
      updateParams.push(timestamp);
    }

    if (updateFields.length === 0) {
      return res.status(400).json({
        status: 'error',
        message: 'No fields to update'
      });
    }

    updateParams.push(id);
    await pool.execute(
      `UPDATE sensor_data SET ${updateFields.join(', ')} WHERE id = ?`,
      updateParams
    );

    const [updated] = await pool.execute(
      'SELECT * FROM sensor_data WHERE id = ?',
      [id]
    );

    res.json({
      status: 'success',
      message: 'Sensor data updated successfully',
      data: updated[0]
    });
  } catch (error) {
    next(error);
  }
};

const delete = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user.id;
    const role = req.user.role;

    // Check if data exists and user has permission
    let checkQuery = 'SELECT * FROM sensor_data WHERE id = ?';
    const checkParams = [id];
    if (role !== 'admin') {
      checkQuery += ' AND user_id = ?';
      checkParams.push(userId);
    }

    const [existing] = await pool.execute(checkQuery, checkParams);

    if (existing.length === 0) {
      return res.status(404).json({
        status: 'error',
        message: 'Sensor data not found'
      });
    }

    await pool.execute('DELETE FROM sensor_data WHERE id = ?', [id]);

    res.json({
      status: 'success',
      message: 'Sensor data deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};

module.exports = {
  getAll,
  getById,
  create,
  update,
  delete
};
```

---

### 6.5 สร้าง Error Handler

#### 6.5.1 สร้างไฟล์ middleware/errorHandler.js

**สร้างไฟล์ middleware/errorHandler.js:**

```javascript
// middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  console.error('Error:', err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  res.status(statusCode).json({
    status: 'error',
    message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

module.exports = errorHandler;
```

---

### 6.6 สร้าง File Upload

#### 6.6.1 สร้างไฟล์ routes/upload.js

**สร้างไฟล์ routes/upload.js:**

```javascript
// routes/upload.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const { authenticateToken } = require('../middleware/auth');
const dotenv = require('dotenv');

dotenv.config();

// Configure Multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, process.env.UPLOAD_DIR || './uploads');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|pdf|doc|docx/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);

    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  }
});

router.post('/', authenticateToken, upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({
      status: 'error',
      message: 'No file uploaded'
    });
  }

  res.json({
    status: 'success',
    message: 'File uploaded successfully',
    data: {
      filename: req.file.filename,
      path: req.file.path,
      size: req.file.size,
      mimetype: req.file.mimetype
    }
  });
});

module.exports = router;
```

**เพิ่ม Route ใน server.js:**

```javascript
// เพิ่มใน server.js
const uploadRoutes = require('./routes/upload');
app.use('/api/upload', uploadRoutes);
```

---

### 6.7 สร้าง Dockerfile สำหรับ Backend

#### 6.7.1 สร้างไฟล์ Dockerfile

**สร้างไฟล์ Dockerfile:**

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy source code
COPY . .

# Create uploads directory
RUN mkdir -p uploads

# Expose port
EXPOSE 3000

# Start server
CMD ["node", "server.js"]
```

---

## 7. Frontend Implementation

### 7.1 สร้าง Frontend Project

#### 7.1.1 สร้าง Nuxt 3 Project

**คำสั่งสร้าง Project:**

```bash
# บน Development PC (Windows)
cd D:\Skill-PWS
npx nuxi@latest init frontend
cd frontend
npm install
```

#### 7.1.2 ติดตั้ง Dependencies

**คำสั่งติดตั้ง:**

```bash
npm install @nuxtjs/tailwindcss axios jwt-decode pinia @pinia/nuxt
```

#### 7.1.3 ตั้งค่า nuxt.config.ts

**สร้างไฟล์ nuxt.config.ts:**

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt'
  ],
  css: ['~/assets/css/main.css'],
  runtimeConfig: {
    public: {
      apiBase: process.env.API_BASE_URL || 'http://192.168.10.10:3000/api'
    }
  },
  devServer: {
    port: 3001,
    host: '0.0.0.0'
  }
})
```

---

### 7.2 สร้าง Authentication

#### 7.2.1 สร้าง Pinia Store

**สร้างไฟล์ stores/auth.js:**

```javascript
// stores/auth.js
import { defineStore } from 'pinia'
import axios from 'axios'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    token: null
  }),

  getters: {
    isAuthenticated: (state) => !!state.token,
    userRole: (state) => state.user?.role
  },

  actions: {
    async login(username, password) {
      try {
        const response = await axios.post('/api/auth/login', {
          username,
          password
        })

        if (response.data.status === 'success') {
          this.token = response.data.data.token
          this.user = response.data.data.user
          
          // Store in localStorage
          localStorage.setItem('token', this.token)
          localStorage.setItem('user', JSON.stringify(this.user))
          
          return true
        }
        return false
      } catch (error) {
        console.error('Login error:', error)
        return false
      }
    },

    logout() {
      this.user = null
      this.token = null
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      navigateTo('/login')
    },

    loadFromStorage() {
      const token = localStorage.getItem('token')
      const user = localStorage.getItem('user')
      
      if (token && user) {
        this.token = token
        this.user = JSON.parse(user)
      }
    }
  }
})
```

#### 7.2.2 สร้าง Login Page

**สร้างไฟล์ pages/login.vue:**

```vue
<!-- pages/login.vue -->
<template>
  <div class="min-h-screen flex items-center justify-center bg-gray-100">
    <div class="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
      <h1 class="text-2xl font-bold mb-6 text-center">IoT System Login</h1>
      
      <form @submit.prevent="handleLogin">
        <div class="mb-4">
          <label class="block text-gray-700 text-sm font-bold mb-2">
            Username
          </label>
          <input
            v-model="username"
            type="text"
            required
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <div class="mb-6">
          <label class="block text-gray-700 text-sm font-bold mb-2">
            Password
          </label>
          <input
            v-model="password"
            type="password"
            required
            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>
        
        <button
          type="submit"
          class="w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          Login
        </button>
      </form>
      
      <div v-if="error" class="mt-4 text-red-500 text-sm text-center">
        {{ error }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useAuthStore } from '~/stores/auth'

const authStore = useAuthStore()
const username = ref('')
const password = ref('')
const error = ref('')

const handleLogin = async () => {
  error.value = ''
  const success = await authStore.login(username.value, password.value)
  
  if (success) {
    // Redirect based on role
    const role = authStore.userRole
    if (role === 'admin') {
      navigateTo('/admin/dashboard')
    } else if (role === 'user_level_1') {
      navigateTo('/dashboard')
    } else {
      navigateTo('/dashboard')
    }
  } else {
    error.value = 'Invalid username or password'
  }
}
</script>
```

---

### 7.3 สร้าง Dashboard

#### 7.3.1 สร้าง Dashboard Page

**สร้างไฟล์ pages/dashboard.vue:**

```vue
<!-- pages/dashboard.vue -->
<template>
  <div class="container mx-auto p-4">
    <h1 class="text-3xl font-bold mb-6">Dashboard</h1>
    
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
      <div class="bg-white p-6 rounded-lg shadow">
        <h2 class="text-xl font-semibold mb-2">Temperature</h2>
        <p class="text-3xl font-bold">{{ latestTemp }}°C</p>
      </div>
      
      <div class="bg-white p-6 rounded-lg shadow">
        <h2 class="text-xl font-semibold mb-2">Humidity</h2>
        <p class="text-3xl font-bold">{{ latestHumidity }}%</p>
      </div>
      
      <div class="bg-white p-6 rounded-lg shadow">
        <h2 class="text-xl font-semibold mb-2">Status</h2>
        <p class="text-3xl font-bold text-green-500">Active</p>
      </div>
    </div>
    
    <div class="bg-white p-6 rounded-lg shadow">
      <h2 class="text-xl font-semibold mb-4">Recent Sensor Data</h2>
      <table class="w-full">
        <thead>
          <tr class="border-b">
            <th class="text-left p-2">Type</th>
            <th class="text-left p-2">Value</th>
            <th class="text-left p-2">Timestamp</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="item in sensorData" :key="item.id" class="border-b">
            <td class="p-2">{{ item.sensor_type }}</td>
            <td class="p-2">{{ item.sensor_value }}</td>
            <td class="p-2">{{ formatDate(item.timestamp) }}</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import axios from 'axios'
import { useAuthStore } from '~/stores/auth'

const authStore = useAuthStore()
const sensorData = ref([])
const latestTemp = ref(0)
const latestHumidity = ref(0)

const loadSensorData = async () => {
  try {
    const token = authStore.token
    const response = await axios.get('/api/sensor-data', {
      headers: {
        Authorization: `Bearer ${token}`
      },
      params: {
        limit: 10
      }
    })
    
    if (response.data.status === 'success') {
      sensorData.value = response.data.data.items
      
      // Get latest temperature and humidity
      const temp = sensorData.value.find(item => item.sensor_type === 'temperature')
      const humidity = sensorData.value.find(item => item.sensor_type === 'humidity')
      
      if (temp) latestTemp.value = temp.sensor_value
      if (humidity) latestHumidity.value = humidity.sensor_value
    }
  } catch (error) {
    console.error('Error loading sensor data:', error)
  }
}

const formatDate = (dateString) => {
  return new Date(dateString).toLocaleString()
}

onMounted(() => {
  loadSensorData()
  // Refresh every 5 seconds
  setInterval(loadSensorData, 5000)
})
</script>
```

---

### 7.4 สร้าง Dockerfile สำหรับ Frontend

#### 7.4.1 สร้างไฟล์ Dockerfile

**สร้างไฟล์ Dockerfile:**

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install

# Copy source code
COPY . .

# Build application
RUN npm run build

# Expose port
EXPOSE 3001

# Start server
CMD ["npm", "run", "start"]
```

---

## 8. MQTT & Node-RED Setup

### 8.1 ตั้งค่า MQTT Broker (Mosquitto)

#### 8.1.1 สร้าง MQTT Configuration

**สร้างไฟล์ mqtt/config/mosquitto.conf:**

```bash
# สร้าง Directory
mkdir -p ~/iot-system/mqtt/config

# สร้างไฟล์ mosquitto.conf
cat > ~/iot-system/mqtt/config/mosquitto.conf << 'EOF'
listener 1883
allow_anonymous false
password_file /mosquitto/config/passwd
acl_file /mosquitto/config/acl

# WebSocket
listener 9001
protocol websockets
EOF

# สร้างไฟล์ passwd (ต้องสร้าง password file)
# ใช้คำสั่ง mosquitto_passwd
```

#### 8.1.2 สร้าง Password และ ACL File

**คำสั่งสร้าง Password File:**

```bash
# สร้าง Password File (ต้องมี mosquitto_passwd)
# หรือใช้ Docker Container
docker run -it --rm eclipse-mosquitto mosquitto_passwd -c /tmp/passwd mqtt_user
# Password: mqtt_password

# Copy password hash และสร้างไฟล์ passwd
cat > ~/iot-system/mqtt/config/passwd << 'EOF'
mqtt_user:$7$...
EOF

# สร้าง ACL File
cat > ~/iot-system/mqtt/config/acl << 'EOF'
user mqtt_user
topic read sensor/#
topic write sensor/#
topic readwrite command/#
EOF
```

#### 8.1.3 ทดสอบ MQTT ด้วย MQTTX

**MQTTX** เป็น All-in-One MQTT Client Toolbox ที่รองรับ MQTT 5.0, 3.1.1, และ 3.1 มี 3 รูปแบบ:
- **MQTTX Desktop**: GUI Client สำหรับ Desktop (macOS, Windows, Linux)
- **MQTTX CLI**: Command Line Tool สำหรับ Automation
- **MQTTX Web**: Web-based Client สำหรับ Browser

**ดาวน์โหลดและติดตั้ง MQTTX:**

```bash
# Windows: Download จาก https://mqttx.app/
# หรือใช้ Chocolatey
choco install mqttx

# macOS: Download จาก https://mqttx.app/
# หรือใช้ Homebrew
brew install mqttx

# Linux: Download จาก https://mqttx.app/
# หรือใช้ Snap
snap install mqttx

# Docker: ใช้ MQTTX Web
docker run -d -p 8080:80 emqx/mqttx-web
```

**วิธีใช้งาน MQTTX Desktop:**

1. **เปิด MQTTX Desktop**
2. **สร้าง Connection ใหม่:**
   - คลิก "New Connection"
   - ตั้งค่า:
     - **Name**: IoT System MQTT
     - **Host**: 192.168.10.10
     - **Port**: 1883
     - **Username**: mqtt_user
     - **Password**: mqtt_password
     - **Protocol**: mqtt://
   - คลิก "Connect"

3. **Subscribe Topic:**
   - คลิก "New Subscription"
   - ใส่ Topic: `sensor/#`
   - คลิก "Confirm"

4. **Publish Message:**
   - เลือก Topic: `sensor/temp/001`
   - ใส่ Payload: `{"value": 25.5}`
   - เลือก Format: JSON
   - คลิก "Publish"

**วิธีใช้งาน MQTTX CLI:**

```bash
# ติดตั้ง MQTTX CLI
npm install -g @emqx/mqttx-cli

# Connect และ Subscribe
mqttx sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/#" -v

# Publish Message
mqttx pub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/temp/001" -m '{"value": 25.5}'

# Benchmark Test
mqttx bench -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "test/topic" -c 10 -n 1000
```

**วิธีใช้งาน MQTTX Web:**

1. เปิด Browser ไปที่ https://mqttx.app/web
2. หรือ Deploy MQTTX Web บน Server:
   ```bash
   docker run -d -p 8080:80 --name mqttx-web emqx/mqttx-web
   ```
3. เปิด Browser ไปที่ http://192.168.10.10:8080
4. ตั้งค่า Connection เหมือน MQTTX Desktop

**ทดสอบ MQTT Connection:**

```bash
# ทดสอบด้วย MQTTX CLI
# 1. Subscribe
mqttx sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/#" -v

# 2. Publish (ใน Terminal อื่น)
mqttx pub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/temp/001" -m '{"value": 25.5}'

# 3. ควรเห็น Message ใน Terminal ที่ Subscribe
```

**Features ของ MQTTX:**

- ✅ รองรับ MQTT 5.0, 3.1.1, 3.1
- ✅ Multiple Connections
- ✅ Scripts สำหรับ Automation
- ✅ Benchmark Testing
- ✅ IoT Data Simulation
- ✅ AI-powered MQTTX Copilot
- ✅ Color-coded Topics
- ✅ Message History
- ✅ Export/Import Connections

**เอกสารเพิ่มเติม:**
- Website: https://mqttx.app/
- Documentation: https://mqttx.app/docs
- GitHub: https://github.com/emqx/MQTTX

---

### 8.2 ตั้งค่า Node-RED

#### 8.2.1 สร้าง Node-RED Flow

**สร้างไฟล์ nodered/flows.json:**

```json
[
  {
    "id": "mqtt-in-1",
    "type": "mqtt in",
    "name": "Sensor Temperature",
    "topic": "sensor/temp/#",
    "qos": "1",
    "broker": "mqtt-broker-1",
    "x": 100,
    "y": 100
  },
  {
    "id": "function-1",
    "type": "function",
    "name": "Process Data",
    "func": "const data = JSON.parse(msg.payload);\nmsg.payload = {\n    user_id: 1,\n    sensor_type: 'temperature',\n    sensor_value: parseFloat(data.value),\n    mqtt_topic: msg.topic,\n    timestamp: new Date().toISOString()\n};\nreturn msg;",
    "x": 300,
    "y": 100
  },
  {
    "id": "mysql-1",
    "type": "mysql",
    "name": "Save to Database",
    "host": "db",
    "port": "3306",
    "user": "iot_user",
    "password": "iot_password_123",
    "database": "iot_db",
    "sql": "INSERT INTO sensor_data (user_id, sensor_type, sensor_value, mqtt_topic, timestamp) VALUES (?, ?, ?, ?, ?)",
    "x": 500,
    "y": 100
  }
]
```

---

## 9. ESP32 Implementation

### 9.1 เขียนโค้ด Arduino

#### 9.1.1 สร้างไฟล์ ESP32 Code

**สร้างไฟล์ esp32/esp32_sensor.ino:**

```cpp
// esp32_sensor.ino
#include <WiFi.h>
#include <PubSubClient.h>
#include <DHT.h>

#define DHT_PIN 4
#define DHT_TYPE DHT22

DHT dht(DHT_PIN, DHT_TYPE);

// WiFi Credentials (เชื่อมต่อกับ Access Point ใน VLAN XX)
const char* ssid = "@wifi";
const char* password = "12345678";

// MQTT Broker
const char* mqtt_server = "192.168.10.10";
const int mqtt_port = 1883;
const char* mqtt_user = "mqtt_user";
const char* mqtt_password = "mqtt_password";

// MQTT Topics
const char* pub_topic_temp = "sensor/temp/001";
const char* pub_topic_humidity = "sensor/humidity/001";
const char* sub_topic = "command/device001/#";

WiFiClient espClient;
PubSubClient client(espClient);

void setup_wifi() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  
  Serial.println("");
  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  String message = "";
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  Serial.println(message);
  
  if (String(topic) == "command/device001/on") {
    // Turn on device
    digitalWrite(LED_BUILTIN, HIGH);
  } else if (String(topic) == "command/device001/off") {
    // Turn off device
    digitalWrite(LED_BUILTIN, LOW);
  }
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    
    if (client.connect("ESP32Client", mqtt_user, mqtt_password)) {
      Serial.println("connected");
      client.subscribe(sub_topic);
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  dht.begin();
  setup_wifi();
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  float temp = dht.readTemperature();
  float humidity = dht.readHumidity();
  
  if (!isnan(temp) && !isnan(humidity)) {
    char tempMsg[50];
    char humidityMsg[50];
    sprintf(tempMsg, "{\"value\":%.2f}", temp);
    sprintf(humidityMsg, "{\"value\":%.2f}", humidity);
    
    client.publish(pub_topic_temp, tempMsg);
    client.publish(pub_topic_humidity, humidityMsg);
    
    Serial.print("Temperature: ");
    Serial.print(temp);
    Serial.print("°C, Humidity: ");
    Serial.print(humidity);
    Serial.println("%");
  }
  
  delay(5000);
}
```

---

## 10. Docker Compose Configuration

### 10.1 สร้าง docker-compose.yml

#### 10.1.1 โครงสร้างไฟล์

**โครงสร้างโฟลเดอร์:**
```
D:\Skill-PWS\
├─ docker-compose.yml
├─ docker-compose.dev.yml
├─ docker-compose.prod.yml
├─ dev.env
├─ prod.env
├─ backend\
│   ├─ Dockerfile
│   ├─ package.json
│   └─ ...
├─ frontend\
│   ├─ Dockerfile
│   ├─ package.json
│   └─ ...
└─ mqtt\
    └─ config\
        ├─ mosquitto.conf
        ├─ passwd
        └─ acl
```

#### 10.1.2 สร้างไฟล์ docker-compose.yml

**ไฟล์: `docker-compose.yml`**
```yaml
version: '3.8'

services:
  # Backend Service
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: iot-backend
    ports:
      - "3000:3000"
    env_file:
      - prod.env
    environment:
      - NODE_ENV=production
      - DB_HOST=db
      - DB_PORT=3306
      - DB_USER=iot_user
      - DB_PASSWORD=iot_password_123
      - DB_NAME=iot_db
      - JWT_SECRET=your-secret-key-change-this
      - MQTT_HOST=mqtt
      - MQTT_PORT=1883
    volumes:
      - ./backend:/app
      - /app/node_modules
      - uploads:/app/uploads
    depends_on:
      - db
      - mqtt
    networks:
      - iot-network
    restart: unless-stopped

  # Frontend Service
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: iot-frontend
    ports:
      - "3001:3001"
    env_file:
      - prod.env
    environment:
      - NODE_ENV=production
      - API_BASE_URL=http://192.168.10.10:3000/api
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.nuxt
    depends_on:
      - backend
    networks:
      - iot-network
    restart: unless-stopped

  # Database Service
  db:
    image: mariadb:10.11
    container_name: iot-db
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword
      - MYSQL_DATABASE=iot_db
      - MYSQL_USER=iot_user
      - MYSQL_PASSWORD=iot_password_123
    volumes:
      - db_data:/var/lib/mysql
      - ./database/init:/docker-entrypoint-initdb.d
    networks:
      - iot-network
    restart: unless-stopped
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci

  # MQTT Broker
  mqtt:
    image: eclipse-mosquitto:latest
    container_name: iot-mqtt
    ports:
      - "1883:1883"
      - "9001:9001"
    volumes:
      - ./mqtt/config/mosquitto.conf:/mosquitto/config/mosquitto.conf
      - ./mqtt/config/passwd:/mosquitto/config/passwd
      - ./mqtt/config/acl:/mosquitto/config/acl
      - mqtt_data:/mosquitto/data
      - mqtt_log:/mosquitto/log
    networks:
      - iot-network
    restart: unless-stopped

  # Node-RED
  nodered:
    image: nodered/node-red:latest
    container_name: iot-nodered
    ports:
      - "1880:1880"
    volumes:
      - nodered_data:/data
    environment:
      - TZ=Asia/Bangkok
    networks:
      - iot-network
    restart: unless-stopped
    depends_on:
      - db
      - mqtt

  # phpMyAdmin (Optional - สำหรับจัดการ Database)
  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest
    container_name: iot-phpmyadmin
    ports:
      - "8080:80"
    environment:
      - PMA_HOST=db
      - PMA_USER=root
      - PMA_PASSWORD=rootpassword
    depends_on:
      - db
    networks:
      - iot-network
    restart: unless-stopped

volumes:
  db_data:
    driver: local
  nodered_data:
    driver: local
  mqtt_data:
    driver: local
  mqtt_log:
    driver: local
  uploads:
    driver: local

networks:
  iot-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

#### 10.1.3 สร้างไฟล์ Environment Variables

**ไฟล์: `dev.env`**
```env
# Development Environment
NODE_ENV=development
API_BASE_URL=http://localhost:3000/api
DB_HOST=localhost
DB_PORT=3306
DB_USER=iot_user
DB_PASSWORD=iot_password_123
DB_NAME=iot_db
JWT_SECRET=dev-secret-key-change-in-production
JWT_EXPIRES_IN=24h
MQTT_HOST=localhost
MQTT_PORT=1883
MQTT_USER=mqtt_user
MQTT_PASSWORD=mqtt_password
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760
```

**ไฟล์: `prod.env`**
```env
# Production Environment
NODE_ENV=production
API_BASE_URL=http://192.168.10.10:3000/api
DB_HOST=db
DB_PORT=3306
DB_USER=iot_user
DB_PASSWORD=iot_password_123
DB_NAME=iot_db
JWT_SECRET=production-secret-key-must-be-strong
JWT_EXPIRES_IN=24h
MQTT_HOST=mqtt
MQTT_PORT=1883
MQTT_USER=mqtt_user
MQTT_PASSWORD=mqtt_password
UPLOAD_DIR=/app/uploads
MAX_FILE_SIZE=10485760
```

#### 10.1.4 สร้างไฟล์ docker-compose.dev.yml

**ไฟล์: `docker-compose.dev.yml`**
```yaml
version: '3.8'

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    volumes:
      - ./backend:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
    command: npm run dev

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.nuxt
    environment:
      - NODE_ENV=development
    command: npm run dev
```

### 10.2 สร้าง Dockerfile สำหรับ Backend

**ไฟล์: `backend/Dockerfile`**
```dockerfile
# Production Dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application files
COPY . .

# Create uploads directory
RUN mkdir -p /app/uploads

# Expose port
EXPOSE 3000

# Start application
CMD ["node", "server.js"]
```

**ไฟล์: `backend/Dockerfile.dev`**
```dockerfile
# Development Dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev)
RUN npm install

# Copy application files
COPY . .

# Create uploads directory
RUN mkdir -p /app/uploads

# Expose port
EXPOSE 3000

# Start application in development mode
CMD ["npm", "run", "dev"]
```

### 10.3 สร้าง Dockerfile สำหรับ Frontend

**ไฟล์: `frontend/Dockerfile`**
```dockerfile
# Production Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy application files
COPY . .

# Build application
RUN npm run build

# Production stage
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install only production dependencies
RUN npm ci --only=production

# Copy built application from builder
COPY --from=builder /app/.nuxt ./.nuxt
COPY --from=builder /app/.output ./.output
COPY --from=builder /app/nuxt.config.ts ./nuxt.config.ts
COPY --from=builder /app/public ./public

# Expose port
EXPOSE 3001

# Start application
CMD ["node", ".output/server/index.mjs"]
```

**ไฟล์: `frontend/Dockerfile.dev`**
```dockerfile
# Development Dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies
RUN npm install

# Copy application files
COPY . .

# Expose port
EXPOSE 3001

# Start application in development mode
CMD ["npm", "run", "dev"]
```

### 10.4 ตั้งค่า MQTT Configuration

**ไฟล์: `mqtt/config/mosquitto.conf`**
```
# Mosquitto Configuration
listener 1883
allow_anonymous false
password_file /mosquitto/config/passwd
acl_file /mosquitto/config/acl

# WebSocket Support
listener 9001
protocol websockets

# Logging
log_dest file /mosquitto/log/mosquitto.log
log_type error
log_type warning
log_type notice
log_type information

# Persistence
persistence true
persistence_location /mosquitto/data/
```

**สร้าง Password File:**
```bash
# สร้าง password file
docker run -it --rm -v $(pwd)/mqtt/config:/mosquitto/config eclipse-mosquitto mosquitto_passwd -c /mosquitto/config/passwd mqtt_user
# Password: mqtt_password
```

**ไฟล์: `mqtt/config/acl`**
```
user mqtt_user
topic read sensor/#
topic write sensor/#
topic readwrite command/#
```

### 10.5 คำสั่งการใช้งาน Docker Compose

#### 10.5.1 Build และ Start Services

```bash
# Build และ Start ทุก Services
docker-compose up -d

# Build เฉพาะ Service ที่ระบุ
docker-compose build backend
docker-compose build frontend

# Start Services โดยไม่ Build
docker-compose up -d

# ดู Logs
docker-compose logs -f
docker-compose logs -f backend
docker-compose logs -f frontend

# ดู Status
docker-compose ps
```

#### 10.5.2 Stop และ Remove Services

```bash
# Stop Services
docker-compose stop

# Stop และ Remove Containers
docker-compose down

# Stop, Remove Containers และ Volumes
docker-compose down -v

# Remove Specific Service
docker-compose rm backend
```

#### 10.5.3 Development Mode

```bash
# ใช้ Development Configuration
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d

# หรือ
docker-compose --env-file dev.env up -d
```

#### 10.5.4 Production Mode

```bash
# ใช้ Production Configuration
docker-compose --env-file prod.env up -d

# Build และ Deploy
docker-compose --env-file prod.env build
docker-compose --env-file prod.env up -d
```

### 10.6 ตรวจสอบและทดสอบ

#### 10.6.1 ตรวจสอบ Services

```bash
# ตรวจสอบ Containers
docker-compose ps

# ตรวจสอบ Logs
docker-compose logs backend
docker-compose logs frontend
docker-compose logs db
docker-compose logs mqtt
docker-compose logs nodered

# ตรวจสอบ Network
docker network ls
docker network inspect skill-pws_iot-network

# ตรวจสอบ Volumes
docker volume ls
docker volume inspect skill-pws_db_data
```

#### 10.6.2 ทดสอบ Connectivity

```bash
# ทดสอบ Backend API
curl http://localhost:3000/api/health
curl http://192.168.10.10:3000/api/health

# ทดสอบ Frontend
curl http://localhost:3001
curl http://192.168.10.10:3001

# ทดสอบ Database
docker-compose exec db mysql -u iot_user -p iot_db

# ทดสอบ MQTT (ใช้ mosquitto commands)
docker-compose exec mqtt mosquitto_pub -h localhost -p 1883 -u mqtt_user -P mqtt_password -t "test/topic" -m "Hello MQTT"
docker-compose exec mqtt mosquitto_sub -h localhost -p 1883 -u mqtt_user -P mqtt_password -t "test/#" -v

# ทดสอบ MQTT ด้วย MQTTX CLI (แนะนำ)
# ติดตั้ง: npm install -g @emqx/mqttx-cli
mqttx sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/#" -v
mqttx pub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password -t "sensor/temp/001" -m '{"value": 25.5}'

# หรือใช้ MQTTX Desktop/Web (GUI)
# Download: https://mqttx.app/
# Connect to: 192.168.10.10:1883
# Username: mqtt_user, Password: mqtt_password

# ทดสอบ Node-RED
curl http://localhost:1880
curl http://192.168.10.10:1880
```

### 10.7 ปัญหาที่ต้องเจอและวิธีแก้ไข

#### 10.7.1 Container ไม่สามารถ Start ได้

**ปัญหา:** Container Exit ทันที
```bash
# ตรวจสอบ Logs
docker-compose logs [service-name]

# ตรวจสอบ Container Status
docker-compose ps -a

# ตรวจสอบ Configuration
docker-compose config
```

**วิธีแก้:**
- ตรวจสอบ Environment Variables
- ตรวจสอบ Port Conflicts
- ตรวจสอบ Volume Mounts
- ตรวจสอบ Dependencies (depends_on)

#### 10.7.2 Network Connectivity Issues

**ปัญหา:** Services ไม่สามารถสื่อสารกันได้
```bash
# ตรวจสอบ Network
docker network inspect skill-pws_iot-network

# ทดสอบ Connectivity จาก Container
docker-compose exec backend ping db
docker-compose exec backend ping mqtt
```

**วิธีแก้:**
- ตรวจสอบ Network Configuration
- ใช้ Service Names แทน IP Address
- ตรวจสอบ depends_on

#### 10.7.3 Volume Mount Issues

**ปัญหา:** ไฟล์ไม่ Sync ระหว่าง Host และ Container
```bash
# ตรวจสอบ Volume Mounts
docker-compose exec backend ls -la /app
docker-compose exec frontend ls -la /app
```

**วิธีแก้:**
- ตรวจสอบ Volume Paths
- ใช้ Named Volumes สำหรับ Production
- ใช้ Bind Mounts สำหรับ Development

### 10.8 Best Practices

1. **Environment Variables:**
   - ใช้ `.env` files สำหรับ Configuration
   - แยก `dev.env` และ `prod.env`
   - ไม่ Commit `.env` files ที่มี Sensitive Data

2. **Volumes:**
   - ใช้ Named Volumes สำหรับ Production Data
   - ใช้ Bind Mounts สำหรับ Development
   - Backup Volumes เป็นประจำ

3. **Networks:**
   - ใช้ Custom Networks สำหรับ Isolation
   - ใช้ Service Names สำหรับ Internal Communication

4. **Security:**
   - เปลี่ยน Default Passwords
   - ใช้ Strong Secrets สำหรับ JWT
   - Limit Exposed Ports

5. **Performance:**
   - ใช้ Multi-stage Builds สำหรับ Production
   - Optimize Dockerfile Layers
   - Use .dockerignore

### 10.9 คำสั่งเพิ่มเติม

```bash
# Restart Specific Service
docker-compose restart backend

# Rebuild และ Restart
docker-compose up -d --build backend

# Execute Command ใน Container
docker-compose exec backend sh
docker-compose exec db mysql -u root -p

# Copy Files จาก/ไป Container
docker cp backend:/app/uploads ./local-uploads
docker cp ./local-file backend:/app/

# View Resource Usage
docker stats

# Clean Up
docker-compose down -v --remove-orphans
docker system prune -a
```

---