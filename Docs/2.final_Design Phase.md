# Design Phase - IoT System with MQTT, Node-RED, ESP32

## 1. บทนำ (Introduction)

### 1.1 ความหมาย/การใช้งาน/คืออะไร
Design Phase เป็นขั้นตอนการออกแบบระบบก่อนการพัฒนา โดยครอบคลุมการออกแบบสถาปัตยกรรมระบบ เครือข่าย ฐานข้อมูล API หน้าจอ และกระบวนการทำงานของระบบทั้งหมด เพื่อให้การพัฒนามีทิศทางที่ชัดเจนและสามารถทำงานได้ตามความต้องการ

### 1.2 วัตถุประสงค์
- ออกแบบระบบให้สอดคล้องกับเกณฑ์การให้คะแนน
- เลือกใช้เทคโนโลยีที่ง่ายที่สุด เร็วที่สุด เพื่อให้สามารถทำได้ภายใน 24 ชั่วโมง
- เน้นการทำงานที่จำเป็นและให้คะแนนสูงสุด

---

## 2. System Architecture Design

### 2.1 Network Architecture

#### 2.1.1 ความหมาย/การใช้งาน/คืออะไร
Network Architecture คือการออกแบบโครงสร้างเครือข่ายที่เชื่อมต่ออุปกรณ์ต่างๆ ในระบบเข้าด้วยกัน ประกอบด้วย Router, Switch, VMs, IoT Devices และ Client Devices

#### 2.1.2 รูปแบบ/Design

**Network Topology:**
```
Internet
  ↓
ROUTER/FIREWALL (กรรมการ)
  ↓
SWITCH (กรรมการ)
  ↓
Container Registry Server (กรรมการ)
  ↓
ROUTER (ผู้เข้าแข่งขัน) - TP-LINK Archer AX10 (ตัวหลัก)
  ├─ IP: 192.168.100.1
  ├─ SSID: @iot
  ├─ Key: 12345678
  ├─ NAT: Enabled
  ├─ Inter-VLAN Routing: Router-on-a-Stick
  └─ DHCP: 192.168.100.30-50
  ↓
L2 Managed Switch - HP JG920A 1920-8G
  ├─ Port 1: Trunk (เชื่อมต่อ Router - Router-on-a-Stick)
  ├─ VLAN 10 (Server/IoT)
  │   ├─ Port 2: VM Server (Proxmox)
  │   │   ├─ VM1: Git Server (git.sisat.lan) - 192.168.10.20
  │   │   └─ VM2: Production Server (iot.sisat.lan) - 192.168.10.10
  │   ├─ Port 3: Access Point - TP-LINK Router (ตัวที่ 2)
  │   │   ├─ SSID: @wifi
  │   │   └─ IoT Devices (ESP32)
  │   └─ Network: 192.168.10.0/24
  └─ VLAN 20 (Development)
      ├─ Port 4-5: Development PCs
      └─ Network: 192.168.20.0/24
```

**IP Address Plan:**

**VLAN 10 (Server/IoT):**
- Network: 192.168.10.0/24
- Subnet Mask: 255.255.255.0
- Gateway: 192.168.10.1 (Router Interface)
- Production VM: 192.168.10.10
- Git Server VM: 192.168.10.20
- DHCP Range: 192.168.10.30-50

**VLAN 20 (Development):**
- Network: 192.168.20.0/24
- Subnet Mask: 255.255.255.0
- Gateway: 192.168.20.1 (Router Interface)
- DHCP Range: 192.168.20.30-50

**Router (TP-LINK Archer AX10):**
- WAN IP: (จากกรรมการ)
- LAN IP: 192.168.100.1/24
- VLAN 10 Interface: 192.168.10.1/24
- VLAN 20 Interface: 192.168.20.1/24

#### 2.1.3 วิธีการทำ
1. ตั้งค่า Router TP-LINK ตัวหลัก (Archer AX10)
   - เข้าสู่ระบบผ่าน 192.168.100.1
   - ตั้งค่า SSID: @iot, Password: 12345678
   - ตั้งค่า DHCP Server: 192.168.100.30-50
   - ตั้งค่า Gateway: 192.168.100.1

2. ตั้งค่า Router TP-LINK ตัวที่ 2 (Access Point Mode)
   - เชื่อมต่อ Router ตัวที่ 2 เข้ากับ L3 Switch ใน VLAN XX
   - ตั้งค่าเป็น Access Point Mode
   - ตั้งค่า SSID: @wifi, Password: 12345678
   - ตั้งค่าให้อยู่ใน VLAN XX
   - ESP32 จะเชื่อมต่อผ่าน Access Point นี้

3. ติดตั้ง Proxmox บน VM Server
   - Download ISO จาก proxmox.com
   - ติดตั้งและตั้งค่า Network Bridge

4. สร้าง VMs บน Proxmox
   - VM1: Git Server (Ubuntu 24.04 LTS Server)
   - VM2: Production Server (Ubuntu 24.04 LTS Server)

#### 2.1.4 วิธีเช็ค
```bash
# เช็ค IP Address
ip addr show
hostname -I

# เช็ค Network Connectivity
ping 192.168.10.1    # Gateway VLAN 10
ping 192.168.20.1    # Gateway VLAN 20
ping 192.168.10.10   # Production VM
ping 192.168.10.20   # Git Server VM

# เช็ค DNS
nslookup git.sisat.lan
nslookup iot.sisat.lan

# เช็ค DHCP
cat /etc/netplan/*.yaml
```

#### 2.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** VM ไม่สามารถเชื่อมต่อ Network ได้
  - **วิธีแก้:** ตรวจสอบ Network Bridge ใน Proxmox และตั้งค่า VM Network Interface
- **ปัญหา:** DNS ไม่ทำงาน
  - **วิธีแก้:** แก้ไข /etc/hosts หรือตั้งค่า DNS Server
- **ระวัง:** ต้องตั้งค่า Static IP ให้ถูกต้องตามที่กำหนด

#### 2.1.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# ตั้งค่า Static IP (Ubuntu 24.04)
sudo nano /etc/netplan/00-installer-config.yaml
# เนื้อหา:
network:
  version: 2
  ethernets:
    eth0:
      addresses:
        - 192.168.10.10/24
      routes:
        - to: default
          via: 192.168.10.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4

sudo netplan apply

# ตั้งค่า Hostname
sudo hostnamectl set-hostname iot.sisat.lan
# หรือ
sudo hostnamectl set-hostname git.sisat.lan

# ตั้งค่า /etc/hosts
sudo nano /etc/hosts
# เพิ่ม:
192.168.10.10 iot.sisat.lan
192.168.10.20 git.sisat.lan
```

#### 2.1.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม VLAN แยกสำหรับ Production และ Development
- ใช้ VPN สำหรับ Remote Access
- เพิ่ม Load Balancer สำหรับ High Availability

---

### 2.1.8 Network Configuration (VLAN, Inter-VLAN Routing, DHCP Snooping, NAT)

#### 2.1.8.1 VLAN Configuration

**ความหมาย/การใช้งาน/คืออะไร:**
VLAN (Virtual LAN) คือการแบ่งเครือข่ายแบบ Logical เพื่อแยก Broadcast Domain และเพิ่มความปลอดภัย โดยใช้ L2 Managed Switch (HP JG920A 1920-8G)

**รูปแบบ/Design:**

**VLAN Configuration:**
- **VLAN 10 (Server/IoT):** สำหรับ Server, VMs, และ IoT Devices
- **VLAN 20 (Development):** สำหรับ Development PCs

**วิธีการทำ:**

**1. ตั้งค่า VLAN บน HP Switch (HP JG920A 1920-8G):**

```bash
# เข้าสู่ Switch ผ่าน Console หรือ Web Interface
# Default IP: 192.168.1.1 หรือ 192.168.0.1

# สร้าง VLAN 10 (Server/IoT)
vlan 10
 name Server-IoT
 exit

# สร้าง VLAN 20 (Development)
vlan 20
 name Development
 exit

# ตั้งค่า Port 1 เป็น Trunk (เชื่อมต่อ Router)
interface gigabitethernet 1/0/1
 port link-type trunk
 port trunk permit vlan 10 20
 exit

# ตั้งค่า Port 2 เป็น Access VLAN 10 (VM Server)
interface gigabitethernet 1/0/2
 port link-type access
 port access vlan 10
 exit

# ตั้งค่า Port 3 เป็น Access VLAN 10 (Access Point)
interface gigabitethernet 1/0/3
 port link-type access
 port access vlan 10
 exit

# ตั้งค่า Port 4-5 เป็น Access VLAN 20 (Development PCs)
interface range gigabitethernet 1/0/4 to 1/0/5
 port link-type access
 port access vlan 20
 exit
```

**วิธีเช็ค:**
```bash
# ดู VLAN ทั้งหมด
show vlan

# ดู Port Configuration
show interface brief

# ดู VLAN Membership
show vlan id 10
show vlan id 20
```

**ปัญหาที่ต้องเจอ/ข้อความระวัง:**
- **ปัญหา:** Port ไม่สามารถสื่อสารข้าม VLAN ได้
  - **วิธีแก้:** ตรวจสอบว่า Port 1 ตั้งเป็น Trunk และ Router ตั้งค่า Router-on-a-Stick
- **ระวัง:** ต้องตั้งค่า Trunk Port ให้ถูกต้องเพื่อให้ Router สามารถทำ Inter-VLAN Routing ได้

---

#### 2.1.8.2 Inter-VLAN Routing

**ความหมาย/การใช้งาน/คืออะไร:**
Inter-VLAN Routing คือการให้ Router ทำหน้าที่เป็น Gateway ระหว่าง VLAN ต่างๆ โดยใช้ Router-on-a-Stick (Sub-interface) เนื่องจากใช้ L2 Switch

**รูปแบบ/Design:**

**Router-on-a-Stick Configuration:**
- Router TP-LINK Archer AX10 ต้องรองรับ VLAN Tagging (802.1Q)
- สร้าง Sub-interface สำหรับแต่ละ VLAN
- ตั้งค่า IP Address เป็น Gateway ของแต่ละ VLAN

**วิธีการทำ:**

**1. ตั้งค่า Router TP-LINK (ถ้ารองรับ VLAN):**

```bash
# ตั้งค่า VLAN Interface บน Router
# (ขึ้นอยู่กับ Firmware ของ TP-LINK)

# VLAN 10 Interface
interface vlan 10
 ip address 192.168.10.1 255.255.255.0
 ip nat inside
 exit

# VLAN 20 Interface
interface vlan 20
 ip address 192.168.20.1 255.255.255.0
 ip nat inside
 exit

# ตั้งค่า Trunk Port (ถ้ารองรับ)
interface gigabitethernet 0/0/1
 port link-type trunk
 port trunk allow-pass vlan 10 20
 exit
```

**หมายเหตุ:** TP-LINK Router บางรุ่นอาจไม่รองรับ VLAN Tagging โดยตรง ในกรณีนี้:
- ใช้ Router ตัวหลักเป็น Gateway สำหรับ VLAN หลัก
- หรือใช้ Software Router (เช่น pfSense, OPNsense) บน VM

**2. ตั้งค่า Static Routes (ถ้าจำเป็น):**

```bash
# บน Router
ip route 192.168.10.0 255.255.255.0 192.168.10.1
ip route 192.168.20.0 255.255.255.0 192.168.20.1
```

**วิธีเช็ค:**
```bash
# ทดสอบ Inter-VLAN Routing
# จาก VLAN 20 (Development PC) ping ไปยัง VLAN 10 (Server)
ping 192.168.10.10

# จาก VLAN 10 (Server) ping ไปยัง VLAN 20 (Development PC)
ping 192.168.20.30

# ดู Routing Table บน Router
show ip route
```

**ปัญหาที่ต้องเจอ/ข้อความระวัง:**
- **ปัญหา:** Router ไม่รองรับ VLAN Tagging
  - **วิธีแก้:** ใช้ Software Router บน VM หรือใช้ Router ที่รองรับ VLAN
- **ปัญหา:** ไม่สามารถ Ping ข้าม VLAN ได้
  - **วิธีแก้:** ตรวจสอบ Trunk Port, VLAN Configuration, และ Gateway Settings

---

#### 2.1.8.3 DHCP + Snooping

**ความหมาย/การใช้งาน/คืออะไร:**
- **DHCP (Dynamic Host Configuration Protocol):** แจกจ่าย IP Address อัตโนมัติให้กับ Clients
- **DHCP Snooping:** ป้องกัน DHCP Rogue Server และตรวจสอบ DHCP Messages

**รูปแบบ/Design:**

**DHCP Configuration:**
- Router TP-LINK ทำหน้าที่เป็น DHCP Server
- แยก DHCP Pool สำหรับแต่ละ VLAN
- เปิดใช้งาน DHCP Snooping บน Switch

**วิธีการทำ:**

**1. ตั้งค่า DHCP บน Router TP-LINK:**

```bash
# DHCP Pool สำหรับ VLAN 10 (Server/IoT)
ip dhcp pool VLAN10
 network 192.168.10.0 255.255.255.0
 default-router 192.168.10.1
 dns-server 8.8.8.8 8.8.4.4
 range 192.168.10.30 192.168.10.50
 exit

# DHCP Pool สำหรับ VLAN 20 (Development)
ip dhcp pool VLAN20
 network 192.168.20.0 255.255.255.0
 default-router 192.168.20.1
 dns-server 8.8.8.8 8.8.4.4
 range 192.168.20.30 192.168.20.50
 exit
```

**หมายเหตุ:** TP-LINK Router อาจใช้ Web Interface:
- ไปที่ Advanced > Network > DHCP Server
- สร้าง DHCP Pool แยกสำหรับแต่ละ VLAN

**2. ตั้งค่า DHCP Snooping บน HP Switch:**

```bash
# เปิดใช้งาน DHCP Snooping
dhcp-snooping enable

# ตั้งค่า Trusted Port (Port ที่เชื่อมต่อ Router/DHCP Server)
dhcp-snooping trusted interface gigabitethernet 1/0/1

# ตั้งค่า DHCP Snooping สำหรับ VLAN
dhcp-snooping vlan 10
dhcp-snooping vlan 20
```

**วิธีเช็ค:**
```bash
# ดู DHCP Leases
show ip dhcp binding

# ดู DHCP Snooping Status
show dhcp-snooping

# ดู DHCP Snooping Binding Table
show dhcp-snooping binding

# ทดสอบ DHCP
# บน Client: ipconfig /release && ipconfig /renew (Windows)
# บน Client: dhclient -r && dhclient (Linux)
```

**ปัญหาที่ต้องเจอ/ข้อความระวัง:**
- **ปัญหา:** Client ไม่ได้รับ IP Address
  - **วิธีแก้:** ตรวจสอบ DHCP Pool, Gateway, และ Trusted Port
- **ปัญหา:** DHCP Snooping Block DHCP Messages
  - **วิธีแก้:** ตั้งค่า Trusted Port ให้ถูกต้อง
- **ระวัง:** ต้องตั้งค่า Trusted Port สำหรับ Port ที่เชื่อมต่อ DHCP Server

---

#### 2.1.8.4 การทำ NAT (Network Address Translation)

**ความหมาย/การใช้งาน/คืออะไร:**
NAT คือการแปลง Private IP Address เป็น Public IP Address เพื่อให้อุปกรณ์ภายในเครือข่ายสามารถเข้าถึง Internet ได้

**รูปแบบ/Design:**

**NAT Configuration:**
- Router TP-LINK ทำหน้าที่เป็น NAT Gateway
- แปลง Private IP (192.168.10.0/24, 192.168.20.0/24) เป็น Public IP
- ใช้ Port Address Translation (PAT) สำหรับหลาย Clients

**วิธีการทำ:**

**1. ตั้งค่า NAT บน Router TP-LINK:**

```bash
# ตั้งค่า NAT Interface
# WAN Interface (เชื่อมต่อ Internet)
interface wan
 ip nat outside
 exit

# LAN Interface (VLAN 10)
interface vlan 10
 ip nat inside
 exit

# LAN Interface (VLAN 20)
interface vlan 20
 ip nat inside
 exit

# ตั้งค่า NAT Overload (PAT)
ip nat inside source list 1 interface wan overload

# สร้าง Access List สำหรับ NAT
access-list 1 permit 192.168.10.0 0.0.0.255
access-list 1 permit 192.168.20.0 0.0.0.255
```

**หมายเหตุ:** TP-LINK Router มักจะเปิด NAT อัตโนมัติผ่าน Web Interface:
- ไปที่ Advanced > Network > NAT
- เปิดใช้งาน NAT/PAT
- ตั้งค่า WAN Interface

**2. ตั้งค่า Port Forwarding (ถ้าจำเป็น):**

```bash
# Port Forwarding สำหรับ Backend API (Port 3000)
# Forward Port 3000 จาก WAN ไปยัง 192.168.10.10:3000

# Port Forwarding สำหรับ Frontend (Port 3001)
# Forward Port 3001 จาก WAN ไปยัง 192.168.10.10:3001
```

**วิธีเช็ค:**
```bash
# ดู NAT Table
show ip nat translations

# ทดสอบ NAT
# จาก Client ใน VLAN 10 หรือ VLAN 20
ping 8.8.8.8
curl ifconfig.me  # ดู Public IP

# ตรวจสอบ Internet Connectivity
ping google.com
```

**ปัญหาที่ต้องเจอ/ข้อความระวัง:**
- **ปัญหา:** ไม่สามารถเข้าถึง Internet ได้
  - **วิธีแก้:** ตรวจสอบ NAT Configuration, WAN Interface, และ Default Route
- **ปัญหา:** Port Forwarding ไม่ทำงาน
  - **วิธีแก้:** ตรวจสอบ Firewall Rules และ Port Forwarding Configuration
- **ระวัง:** ต้องตั้งค่า NAT Inside/Outside Interface ให้ถูกต้อง

---

#### 2.1.8.5 สรุปคำสั่งการตั้งค่าและทดสอบ

**คำสั่งตั้งค่า Switch (HP JG920A 1920-8G):**
```bash
# เข้าสู่ Switch
# ผ่าน Console หรือ Web Interface: http://192.168.1.1

# สร้าง VLAN
vlan 10
 name Server-IoT
exit
vlan 20
 name Development
exit

# ตั้งค่า Trunk Port
interface gigabitethernet 1/0/1
 port link-type trunk
 port trunk permit vlan 10 20
exit

# ตั้งค่า Access Ports
interface gigabitethernet 1/0/2
 port link-type access
 port access vlan 10
exit

interface range gigabitethernet 1/0/4 to 1/0/5
 port link-type access
 port access vlan 20
exit

# เปิดใช้งาน DHCP Snooping
dhcp-snooping enable
dhcp-snooping trusted interface gigabitethernet 1/0/1
dhcp-snooping vlan 10
dhcp-snooping vlan 20
```

**คำสั่งตรวจสอบ:**
```bash
# ตรวจสอบ VLAN
show vlan
show vlan id 10
show vlan id 20

# ตรวจสอบ Port Configuration
show interface brief
show interface gigabitethernet 1/0/1

# ตรวจสอบ DHCP Snooping
show dhcp-snooping
show dhcp-snooping binding

# ทดสอบ Connectivity
ping 192.168.10.10  # จาก VLAN 20
ping 192.168.20.30  # จาก VLAN 10
ping 8.8.8.8        # ทดสอบ Internet
```

**คำสั่งตั้งค่า VM (Ubuntu 24.04):**
```bash
# ตั้งค่า Static IP สำหรับ Production VM (VLAN 10)
sudo nano /etc/netplan/00-installer-config.yaml
# เนื้อหา:
network:
  version: 2
  ethernets:
    eth0:
      addresses:
        - 192.168.10.10/24
      routes:
        - to: default
          via: 192.168.10.1
      nameservers:
        addresses:
          - 8.8.8.8
          - 8.8.4.4

sudo netplan apply

# ตั้งค่า Static IP สำหรับ Git Server VM (VLAN 10)
# เปลี่ยน IP เป็น 192.168.10.20/24 และ Gateway เป็น 192.168.10.1
```

---

### 2.2 Virtualization Architecture (Proxmox)

#### 2.2.1 ความหมาย/การใช้งาน/คืออะไร
Proxmox เป็นระบบ Virtualization แบบ Open Source ที่ใช้จัดการ Virtual Machines และ Containers บนเครื่อง Server เดียว

#### 2.2.2 รูปแบบ/Design

**VM Configuration:**
- **VM1: Git Server**
  - OS: Ubuntu 24.04 LTS Server
  - Hostname: git.sisat.lan
  - IP: 192.168.10.20 (VLAN 10)
  - User: it / Password: 12345678
  - Services: GitLab, GitLab Runner (CI/CD)

- **VM2: Production Server**
  - OS: Ubuntu 24.04 LTS Server
  - Hostname: iot.sisat.lan
  - IP: 192.168.10.10 (VLAN 10)
  - User: it / Password: 12345678
  - Services: Docker, Backend, Frontend, Database, MQTT, Node-RED

#### 2.2.3 วิธีการทำ
1. ติดตั้ง Proxmox
   - Download ISO จาก proxmox.com
   - Boot จาก USB/DVD
   - ติดตั้งตาม Wizard

2. สร้าง VM
   - คลิก "Create VM"
   - เลือก Ubuntu 24.04 LTS Server ISO
   - กำหนด RAM: 4GB, CPU: 2 cores, Disk: 20GB
   - ตั้งค่า Network Bridge

3. ติดตั้ง Ubuntu บน VM
   - Boot VM และติดตั้ง Ubuntu
   - ตั้งค่า Static IP, Hostname, User

#### 2.2.4 วิธีเช็ค
```bash
# เช็ค Proxmox Web UI
# เข้าผ่าน https://[Proxmox-IP]:8006

# เช็ค VM Status
qm list

# เช็ค VM Network
qm config [VM-ID]
```

#### 2.2.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** VM ไม่สามารถ Boot ได้
  - **วิธีแก้:** ตรวจสอบ ISO Image และ Boot Order
- **ปัญหา:** Network ไม่ทำงาน
  - **วิธีแก้:** ตั้งค่า Bridge Network ใน Proxmox
- **ระวัง:** ต้องมี RAM อย่างน้อย 16GB สำหรับ Host Machine

#### 2.2.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# ใน Proxmox Host
qm list                    # แสดงรายการ VMs
qm status [VM-ID]         # เช็คสถานะ VM
qm config [VM-ID]         # แสดงการตั้งค่า VM

# ใน VM (Ubuntu)
sudo systemctl status     # เช็ค Services
sudo ufw status          # เช็ค Firewall
```

#### 2.2.7 แนวทางในการพัฒนาในอนาคต
- ใช้ Proxmox Cluster สำหรับ High Availability
- เพิ่ม Backup System
- ใช้ Proxmox Backup Server

---

### 2.3 SSH Remote Management

#### 2.3.1 ความหมาย/การใช้งาน/คืออะไร
SSH (Secure Shell) เป็นโปรโตคอลสำหรับ Remote Access ไปยัง Linux Server อย่างปลอดภัย

#### 2.3.2 รูปแบบ/Design
- **SSH Access:**
  - User: it (ไม่ใช่ root)
  - Port: 22
  - Authentication: Password หรือ SSH Key
  - Firewall: เปิด Port 22

#### 2.3.3 วิธีการทำ
1. เปิด SSH Service
   ```bash
   sudo systemctl enable ssh
   sudo systemctl start ssh
   ```

2. ตั้งค่า Firewall
   ```bash
   sudo ufw allow 22/tcp
   sudo ufw enable
   ```

3. Remote Access จาก Windows
   - ใช้ PuTTY หรือ Windows Terminal
   - `ssh it@192.168.10.10`  # Production Server
   - `ssh it@192.168.10.20`  # Git Server

#### 2.3.4 วิธีเช็ค
```bash
# เช็ค SSH Service
sudo systemctl status ssh

# เช็ค SSH Port
sudo netstat -tlnp | grep :22
# หรือ
sudo ss -tlnp | grep :22

# ทดสอบ SSH จากเครื่องอื่น
ssh it@192.168.10.10  # Production Server
ssh it@192.168.10.20  # Git Server
```

#### 2.3.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** SSH Connection Refused
  - **วิธีแก้:** ตรวจสอบว่า SSH Service ทำงาน และ Firewall เปิด Port 22
- **ปัญหา:** Permission Denied
  - **วิธีแก้:** ตรวจสอบ Username และ Password
- **ระวัง:** ควรใช้ SSH Key แทน Password สำหรับ Production

#### 2.3.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# ตั้งค่า SSH Key (จาก Windows)
ssh-keygen -t rsa -b 4096
ssh-copy-id it@192.168.10.10  # Production Server
ssh-copy-id it@192.168.10.20  # Git Server

# ใน Server
sudo nano /etc/ssh/sshd_config
# ตั้งค่า:
PermitRootLogin no
PasswordAuthentication yes
PubkeyAuthentication yes

sudo systemctl restart ssh
```

#### 2.3.7 แนวทางในการพัฒนาในอนาคต
- ใช้ SSH Key Authentication
- เปลี่ยน SSH Port จาก 22
- ใช้ Fail2Ban เพื่อป้องกัน Brute Force

---

## 3. DevOps Architecture Design

### 3.1 Docker Architecture

#### 3.1.1 ความหมาย/การใช้งาน/คืออะไร
Docker เป็น Container Technology ที่ใช้สำหรับรัน Application ในสภาพแวดล้อมที่แยกออกจากกัน (Isolated Environment)

#### 3.1.2 รูปแบบ/Design

**Container Services:**
```
Production Server (iot.sisat.lan)
├─ Backend Container (Node.js 18+)
│   └─ Port: 3000
├─ Frontend Container (Nuxt 3)
│   └─ Port: 3001
├─ MySQL/MariaDB Container
│   └─ Port: 3306
├─ MQTT Broker (Eclipse Mosquitto)
│   └─ Port: 1883, 9001
├─ Node-RED Container
│   └─ Port: 1880
└─ phpMyAdmin (Optional)
    └─ Port: 8080
```

**Docker Compose Structure:**
```
D:\Skill-PWS\
├─ docker-compose.yml
├─ dev.env
├─ prod.env
├─ backend\
│   ├─ Dockerfile
│   └─ ...
└─ frontend\
    ├─ Dockerfile
    └─ ...
```

#### 3.1.3 วิธีการทำ
1. ติดตั้ง Docker บน Production VM
   ```bash
   curl -fsSL https://get.docker.com -o get-docker.sh
   sudo sh get-docker.sh
   sudo usermod -aG docker it
   ```

2. สร้าง Dockerfile สำหรับ Backend
   ```dockerfile
   FROM node:18-alpine
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   EXPOSE 3000
   CMD ["node", "server.js"]
   ```

3. สร้าง Dockerfile สำหรับ Frontend
   ```dockerfile
   FROM node:18-alpine
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   RUN npm run build
   EXPOSE 3001
   CMD ["npm", "run", "start"]
   ```

4. สร้าง docker-compose.yml
   ```yaml
   version: '3.8'
   services:
     backend:
       build: ./backend
       ports:
         - "3000:3000"
       env_file:
         - prod.env
       depends_on:
         - db
     
     frontend:
       build: ./frontend
       ports:
         - "3001:3001"
       env_file:
         - prod.env
       depends_on:
         - backend
     
     db:
       image: mariadb:10.11
       environment:
         MYSQL_ROOT_PASSWORD: rootpassword
         MYSQL_DATABASE: iot_db
       volumes:
         - db_data:/var/lib/mysql
       ports:
         - "3306:3306"
     
     mqtt:
       image: eclipse-mosquitto:latest
       ports:
         - "1883:1883"
         - "9001:9001"
       volumes:
         - ./mqtt/config:/mosquitto/config
     
     nodered:
       image: nodered/node-red:latest
       ports:
         - "1880:1880"
       volumes:
         - nodered_data:/data
   
   volumes:
     db_data:
     nodered_data:
   ```

#### 3.1.4 วิธีเช็ค
```bash
# เช็ค Docker Version
docker --version
docker-compose --version

# เช็ค Running Containers
docker ps
docker-compose ps

# เช็ค Container Logs
docker logs [container-name]
docker-compose logs

# เช็ค Container Status
docker stats
```

#### 3.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** Container ไม่สามารถ Start ได้
  - **วิธีแก้:** ตรวจสอบ Logs ด้วย `docker logs [container-name]`
- **ปัญหา:** Port Already in Use
  - **วิธีแก้:** เปลี่ยน Port หรือหยุด Service ที่ใช้ Port นั้น
- **ระวัง:** ต้อง Build Image ก่อน Run Container

#### 3.1.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# Build และ Run
docker-compose build
docker-compose up -d

# Stop และ Remove
docker-compose down

# Rebuild Specific Service
docker-compose build backend
docker-compose up -d backend

# Execute Command in Container
docker-compose exec backend sh
docker-compose exec db mysql -u root -p
```

#### 3.1.7 แนวทางในการพัฒนาในอนาคต
- ใช้ Docker Swarm หรือ Kubernetes
- เพิ่ม Health Checks
- ใช้ Docker Secrets สำหรับ Sensitive Data

---

### 3.2 GitLab Architecture

#### 3.2.1 ความหมาย/การใช้งาน/คืออะไร
GitLab เป็น Git Server ที่มีฟีเจอร์ CI/CD, Issue Tracking, และ Project Management ในตัว

#### 3.2.2 รูปแบบ/Design

**GitLab Setup:**
- **VM:** git.sisat.lan (192.168.10.20)
- **GitLab:** Docker Container
- **GitLab Runner:** Docker Container
- **Port:** 80, 443, 22

#### 3.2.3 วิธีการทำ
1. ติดตั้ง GitLab ด้วย Docker
   ```bash
   docker run -d \
     --hostname git.sisat.lan \
     --name gitlab \
     -p 80:80 -p 443:443 -p 22:22 \
     -v gitlab_config:/etc/gitlab \
     -v gitlab_logs:/var/log/gitlab \
     -v gitlab_data:/var/opt/gitlab \
     gitlab/gitlab-ce:latest
   ```

2. รอให้ GitLab Start (ใช้เวลาประมาณ 5-10 นาที)
   ```bash
   docker logs -f gitlab
   ```

3. ตั้งค่า Root Password
   - เข้า http://192.168.10.20 หรือ https://192.168.10.20
   - ตั้งค่า Root Password ครั้งแรก

4. ติดตั้ง GitLab Runner
   ```bash
   docker run -d --name gitlab-runner \
     -v gitlab-runner-config:/etc/gitlab-runner \
     -v /var/run/docker.sock:/var/run/docker.sock \
     gitlab/gitlab-runner:latest
   ```

5. Register Runner
   - ไปที่ GitLab > Settings > CI/CD > Runners
   - Copy Registration Token
   ```bash
   docker exec -it gitlab-runner gitlab-runner register
   ```

#### 3.2.4 วิธีเช็ค
```bash
# เช็ค GitLab Status
docker ps | grep gitlab
docker logs gitlab

# เช็ค GitLab Web UI
curl http://192.168.10.20

# เช็ค GitLab Runner
docker exec -it gitlab-runner gitlab-runner list
```

#### 3.2.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** GitLab ใช้ Memory มาก
  - **วิธีแก้:** ตั้งค่า Memory Limit ใน VM หรือใช้ GitLab Lite
- **ปัญหา:** Runner ไม่ทำงาน
  - **วิธีแก้:** ตรวจสอบ Registration Token และ Network Connectivity
- **ระวัง:** GitLab ใช้เวลานานในการ Start ครั้งแรก

#### 3.2.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# ดู GitLab Root Password
docker exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password

# Restart GitLab
docker restart gitlab

# เช็ค GitLab Configuration
docker exec -it gitlab gitlab-ctl status
```

#### 3.2.7 แนวทางในการพัฒนาในอนาคต
- ใช้ GitLab HA
- เพิ่ม GitLab Backup
- ใช้ GitLab Pages สำหรับ Documentation

---

### 3.3 CI/CD Pipeline Design

#### 3.3.1 ความหมาย/การใช้งาน/คืออะไร
CI/CD Pipeline เป็นกระบวนการอัตโนมัติสำหรับ Build, Test, และ Deploy Application เมื่อมีการ Push Code ขึ้น Git

#### 3.3.2 รูปแบบ/Design

**Pipeline Stages:**
```
Git Push
  ↓
Stage 1: Build
  ├─ Build Backend Docker Image
  ├─ Build Frontend Docker Image
  └─ Build Test
  ↓
Stage 2: Test
  ├─ Run Backend Tests
  ├─ Run Frontend Tests
  └─ Integration Tests
  ↓
Stage 3: Deploy
  ├─ Push Images to Registry
  ├─ Deploy to Production VM
  └─ Restart Containers
```

**GitLab CI/CD Configuration (.gitlab-ci.yml):**
```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

build_backend:
  stage: build
  script:
    - cd backend
    - docker build -t backend:latest .
    - docker tag backend:latest registry.sisat.lan/backend:latest
    - docker push registry.sisat.lan/backend:latest
  only:
    - main

build_frontend:
  stage: build
  script:
    - cd frontend
    - docker build -t frontend:latest .
    - docker tag frontend:latest registry.sisat.lan/frontend:latest
    - docker push registry.sisat.lan/frontend:latest
  only:
    - main

test_backend:
  stage: test
  script:
    - cd backend
    - npm install
    - npm test
  only:
    - main

test_frontend:
  stage: test
  script:
    - cd frontend
    - npm install
    - npm test
  only:
    - main

deploy_production:
  stage: deploy
  script:
    - ssh it@192.168.10.10 "cd /opt/app && docker-compose pull && docker-compose up -d"
  only:
    - main
  when: on_success
```

#### 3.3.3 วิธีการทำ
1. สร้างไฟล์ `.gitlab-ci.yml` ใน Root ของ Project
2. ตั้งค่า GitLab Runner ให้รองรับ Docker
3. ตั้งค่า SSH Key สำหรับ Deploy
4. Push Code และดู Pipeline ใน GitLab UI

#### 3.3.4 วิธีเช็ค
```bash
# ดู Pipeline Status
# ไปที่ GitLab > CI/CD > Pipelines

# ดู Pipeline Logs
# คลิกที่ Pipeline > คลิกที่ Job

# ทดสอบ Pipeline
git add .
git commit -m "Test CI/CD"
git push origin main
```

#### 3.3.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** Pipeline Fail ที่ Build Stage
  - **วิธีแก้:** ตรวจสอบ Dockerfile และ Build Context
- **ปัญหา:** Deploy ไม่ทำงาน
  - **วิธีแก้:** ตรวจสอบ SSH Key และ Network Connectivity
- **ระวัง:** ต้องตั้งค่า GitLab Runner ให้ถูกต้อง

#### 3.3.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# ทดสอบ Pipeline Locally (ใช้ GitLab Runner)
gitlab-runner exec docker build_backend

# ดู Runner Status
docker exec -it gitlab-runner gitlab-runner list
```

#### 3.3.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Stage สำหรับ Staging Environment
- เพิ่ม Automated Testing
- ใช้ Blue-Green Deployment

---

## 4. Database Design

### 4.1 Database Architecture

#### 4.1.1 ความหมาย/การใช้งาน/คืออะไร
Database Design คือการออกแบบโครงสร้างฐานข้อมูลที่เก็บข้อมูลของระบบ รวมถึง Tables, Relationships, และ Data Types

#### 4.1.2 รูปแบบ/Design

**Database: iot_db**
- **Type:** MariaDB/MySQL
- **Version:** 10.11 หรือใหม่กว่า
- **Character Set:** utf8mb4
- **Collation:** utf8mb4_unicode_ci

**ER Diagram:**
```
┌─────────────┐
│   users     │
├─────────────┤
│ id (PK)     │
│ username    │
│ password    │
│ email       │
│ role        │ (admin, user_level_1, user_level_2)
│ created_at  │
│ updated_at  │
└──────┬──────┘
       │
       │ 1:N
       │
┌──────▼──────────┐
│  sensor_data   │
├────────────────┤
│ id (PK)        │
│ user_id (FK)   │
│ sensor_type    │
│ sensor_value   │
│ mqtt_topic     │
│ timestamp      │
│ created_at     │
└────────────────┘
       │
       │ 1:N
       │
┌──────▼──────────┐
│  device_config  │
├─────────────────┤
│ id (PK)         │
│ sensor_data_id (FK) │
│ device_name     │
│ device_type     │
│ mqtt_topic      │
│ status          │
│ created_at      │
│ updated_at      │
└─────────────────┘
```

#### 4.1.3 วิธีการทำ

**1. สร้าง Database Schema:**

```sql
-- สร้าง Database
CREATE DATABASE iot_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

USE iot_db;

-- ตาราง users
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    role ENUM('admin', 'user_level_1', 'user_level_2') NOT NULL DEFAULT 'user_level_2',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ตาราง sensor_data
CREATE TABLE sensor_data (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    sensor_type VARCHAR(50) NOT NULL,
    sensor_value DECIMAL(10,2) NOT NULL,
    mqtt_topic VARCHAR(255) NOT NULL,
    timestamp DATETIME NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_id (user_id),
    INDEX idx_timestamp (timestamp),
    INDEX idx_sensor_type (sensor_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ตาราง device_config
CREATE TABLE device_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    sensor_data_id INT,
    device_name VARCHAR(100) NOT NULL,
    device_type VARCHAR(50) NOT NULL,
    mqtt_topic VARCHAR(255) NOT NULL,
    status ENUM('active', 'inactive', 'maintenance') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (sensor_data_id) REFERENCES sensor_data(id) ON DELETE SET NULL,
    INDEX idx_device_name (device_name),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**2. สร้าง User และ Grant Permissions:**

```sql
-- สร้าง User สำหรับ Application
CREATE USER 'iot_user'@'%' IDENTIFIED BY 'iot_password_123';
GRANT SELECT, INSERT, UPDATE, DELETE ON iot_db.* TO 'iot_user'@'%';
FLUSH PRIVILEGES;

-- สร้าง User สำหรับ Admin (Hash Password: admin)
-- Password: admin (ใช้ bcrypt hash)
-- Hash: $2b$10$rOzJqZqZqZqZqZqZqZqZqO (ตัวอย่าง - ต้อง Hash จริง)
```

**3. เพิ่มข้อมูลเริ่มต้น:**

```sql
-- เพิ่ม Admin User (Password: admin - ต้อง Hash ก่อน)
-- ใช้ Node.js เพื่อ Hash Password
INSERT INTO users (username, password, email, role) VALUES
('admin', '$2b$10$rOzJqZqZqZqZqZqZqZqZqO', 'admin@sisat.lan', 'admin');

-- เพิ่ม User Level 1
INSERT INTO users (username, password, email, role) VALUES
('user1', '$2b$10$rOzJqZqZqZqZqZqZqZqZqO', 'user1@sisat.lan', 'user_level_1');

-- เพิ่ม User Level 2
INSERT INTO users (username, password, email, role) VALUES
('user2', '$2b$10$rOzJqZqZqZqZqZqZqZqZqO', 'user2@sisat.lan', 'user_level_2');
```

#### 4.1.4 วิธีเช็ค
```bash
# เช็ค Database Connection
mysql -u iot_user -p -h 192.168.10.10 iot_db

# เช็ค Tables
mysql -u iot_user -p iot_db -e "SHOW TABLES;"

# เช็ค Table Structure
mysql -u iot_user -p iot_db -e "DESCRIBE users;"
mysql -u iot_user -p iot_db -e "DESCRIBE sensor_data;"
mysql -u iot_user -p iot_db -e "DESCRIBE device_config;"

# เช็ค Data
mysql -u iot_user -p iot_db -e "SELECT * FROM users;"
```

#### 4.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** Foreign Key Constraint Failed
  - **วิธีแก้:** ตรวจสอบว่า Foreign Key Reference ถูกต้อง
- **ปัญหา:** Character Encoding ไม่ถูกต้อง
  - **วิธีแก้:** ใช้ utf8mb4 สำหรับรองรับ Emoji และ Special Characters
- **ระวัง:** ต้อง Hash Password ก่อนเก็บใน Database

#### 4.1.6 คำสั่งที่ใช้ในการตรวจสอบ

**Hash Password ด้วย Node.js:**
```javascript
// hash-password.js
const bcrypt = require('bcrypt');

const password = 'admin';
bcrypt.hash(password, 10, (err, hash) => {
    if (err) throw err;
    console.log('Hashed Password:', hash);
    
    // ใช้ Hash นี้ใน SQL INSERT
});
```

**SQL Commands:**
```sql
-- เช็ค Users
SELECT id, username, email, role, created_at FROM users;

-- เช็ค Sensor Data
SELECT sd.*, u.username 
FROM sensor_data sd 
JOIN users u ON sd.user_id = u.id 
ORDER BY sd.timestamp DESC 
LIMIT 10;

-- เช็ค Device Config
SELECT dc.*, sd.sensor_type, sd.sensor_value
FROM device_config dc
LEFT JOIN sensor_data sd ON dc.sensor_data_id = sd.id;

-- เพิ่ม User ใหม่ (ต้อง Hash Password ก่อน)
INSERT INTO users (username, password, email, role) 
VALUES ('newuser', '[HASHED_PASSWORD]', 'newuser@sisat.lan', 'user_level_2');
```

#### 4.1.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Indexes สำหรับ Query Performance
- ใช้ Database Migration Tools (เช่น Knex.js)
- เพิ่ม Database Backup และ Replication
- ใช้ Redis สำหรับ Caching

---

## 5. API Design (RESTful API)

### 5.1 API Architecture

#### 5.1.1 ความหมาย/การใช้งาน/คืออะไร
RESTful API เป็นการออกแบบ API ที่ใช้ HTTP Methods (GET, POST, PUT, DELETE) ตามหลัก REST Architecture

#### 5.1.2 รูปแบบ/Design

**API Base URL:**
- Development: `http://localhost:3000/api`
- Production: `http://iot.sisat.lan:3000/api`

**API Endpoints:**

```
Authentication:
  POST   /api/auth/login          - Login และรับ JWT Token
  POST   /api/auth/logout         - Logout
  GET    /api/auth/me             - ดูข้อมูล User ปัจจุบัน

Users:
  GET    /api/users               - ดูรายการ Users (Admin only)
  GET    /api/users/:id           - ดูข้อมูล User
  POST   /api/users               - สร้าง User ใหม่ (Admin only)
  PUT    /api/users/:id           - แก้ไข User (Admin only)
  DELETE /api/users/:id           - ลบ User (Admin only)

Sensor Data:
  GET    /api/sensor-data         - ดูรายการ Sensor Data (Filter, Pagination)
  GET    /api/sensor-data/:id     - ดูข้อมูล Sensor Data
  POST   /api/sensor-data         - เพิ่ม Sensor Data
  PUT    /api/sensor-data/:id     - แก้ไข Sensor Data
  DELETE /api/sensor-data/:id     - ลบ Sensor Data

Device Config:
  GET    /api/devices             - ดูรายการ Devices
  GET    /api/devices/:id           - ดูข้อมูล Device
  POST   /api/devices             - เพิ่ม Device
  PUT    /api/devices/:id         - แก้ไข Device
  DELETE /api/devices/:id         - ลบ Device

File Upload:
  POST   /api/upload              - อัปโหลดไฟล์
```

#### 5.1.3 วิธีการทำ

**1. API Request/Response Examples:**

**Login API:**
```json
// Request: POST /api/auth/login
{
  "username": "admin",
  "password": "admin"
}

// Response: 200 OK
{
  "status": "success",
  "message": "Login successful",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "id": 1,
      "username": "admin",
      "email": "admin@sisat.lan",
      "role": "admin"
    }
  }
}

// Response: 401 Unauthorized
{
  "status": "error",
  "message": "Invalid username or password",
  "data": null
}
```

**Get Sensor Data API:**
```json
// Request: GET /api/sensor-data?page=1&limit=10&sensor_type=temperature
// Headers: Authorization: Bearer {token}

// Response: 200 OK
{
  "status": "success",
  "message": "Sensor data retrieved successfully",
  "data": {
    "items": [
      {
        "id": 1,
        "user_id": 1,
        "sensor_type": "temperature",
        "sensor_value": 25.5,
        "mqtt_topic": "sensor/temp/001",
        "timestamp": "2024-01-15T10:30:00Z",
        "created_at": "2024-01-15T10:30:00Z"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 10,
      "total": 100,
      "totalPages": 10
    }
  }
}
```

**Create Sensor Data API:**
```json
// Request: POST /api/sensor-data
// Headers: Authorization: Bearer {token}
{
  "sensor_type": "temperature",
  "sensor_value": 26.0,
  "mqtt_topic": "sensor/temp/001",
  "timestamp": "2024-01-15T10:35:00Z"
}

// Response: 201 Created
{
  "status": "success",
  "message": "Sensor data created successfully",
  "data": {
    "id": 2,
    "user_id": 1,
    "sensor_type": "temperature",
    "sensor_value": 26.0,
    "mqtt_topic": "sensor/temp/001",
    "timestamp": "2024-01-15T10:35:00Z",
    "created_at": "2024-01-15T10:35:00Z"
  }
}

// Response: 400 Bad Request
{
  "status": "error",
  "message": "Validation failed",
  "errors": [
    {
      "field": "sensor_value",
      "message": "sensor_value is required"
    }
  ]
}
```

**File Upload API:**
```json
// Request: POST /api/upload
// Headers: Authorization: Bearer {token}
// Content-Type: multipart/form-data
// Body: file (binary)

// Response: 200 OK
{
  "status": "success",
  "message": "File uploaded successfully",
  "data": {
    "filename": "document.pdf",
    "path": "/uploads/document.pdf",
    "size": 1024000,
    "mimetype": "application/pdf"
  }
}
```

#### 5.1.4 วิธีเช็ค
```bash
# ทดสอบ API ด้วย curl
# Login
curl -X POST http://iot.sisat.lan:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin"}'

# Get Sensor Data (ใช้ Token จาก Login)
curl -X GET http://iot.sisat.lan:3000/api/sensor-data \
  -H "Authorization: Bearer {token}"

# ใช้ Postman
# Import Postman Collection (จะสร้างไฟล์ .json)
```

#### 5.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** JWT Token Expired
  - **วิธีแก้:** Refresh Token หรือ Login ใหม่
- **ปัญหา:** CORS Error
  - **วิธีแก้:** ตั้งค่า CORS ใน Backend
- **ระวัง:** ต้อง Validate Input ทุกครั้ง

#### 5.1.6 คำสั่งที่ใช้ในการตรวจสอบ

**Postman Collection Example:**
```json
{
  "info": {
    "name": "IoT System API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "Login",
      "request": {
        "method": "POST",
        "header": [{"key": "Content-Type", "value": "application/json"}],
        "body": {
          "mode": "raw",
          "raw": "{\n  \"username\": \"admin\",\n  \"password\": \"admin\"\n}"
        },
        "url": {
          "raw": "http://iot.sisat.lan:3000/api/auth/login",
          "protocol": "http",
          "host": ["iot", "sisat", "lan"],
          "port": "3000",
          "path": ["api", "auth", "login"]
        }
      }
    }
  ]
}
```

#### 5.1.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม API Rate Limiting
- ใช้ API Versioning (v1, v2)
- เพิ่ม API Documentation (Swagger/OpenAPI)
- เพิ่ม WebSocket สำหรับ Real-time Updates

---

## 6. Frontend Design (Vue 3 + Nuxt 3)

### 6.1 UI/UX Design

#### 6.1.1 ความหมาย/การใช้งาน/คืออะไร
Frontend Design คือการออกแบบหน้าจอผู้ใช้ (User Interface) และประสบการณ์ผู้ใช้ (User Experience) สำหรับ Web Application

#### 6.1.2 รูปแบบ/Design

**Layout Templates:**

**1. Login Screen:**
```
┌─────────────────────────────────────┐
│         IoT System Login            │
├─────────────────────────────────────┤
│                                     │
│   Username: [____________]          │
│   Password: [____________]          │
│                                     │
│   [        Login        ]           │
│                                     │
└─────────────────────────────────────┘
```

**2. Dashboard/Overview:**
```
┌─────────────────────────────────────────────────────┐
│ Header: [Logo] [User Menu] [Logout]                │
├─────────────────────────────────────────────────────┤
│ Sidebar:                                            │
│ - Dashboard                                         │
│ - Sensor Data                                       │
│ - Devices                                           │
│ - Users (Admin only)                                │
│                                                     │
│ Main Content:                                       │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│ │ Temperature │ │  Humidity   │ │   Status    │  │
│ │    25.5°C   │ │    60%      │ │   Active    │  │
│ └─────────────┘ └─────────────┘ └─────────────┘  │
│                                                     │
│ [Chart: Sensor Data Over Time]                     │
│                                                     │
│ [Table: Recent Sensor Data]                         │
└─────────────────────────────────────────────────────┘
```

**3. Admin Template:**
```
┌─────────────────────────────────────────────────────┐
│ Header: [Logo] Admin Panel [User Menu] [Logout]     │
├─────────────────────────────────────────────────────┤
│ Sidebar:                                            │
│ - Dashboard                                         │
│ - Users Management                                  │
│ - Sensor Data                                       │
│ - Devices Management                                │
│ - System Settings                                   │
│                                                     │
│ Main Content:                                       │
│ [Admin-specific content and controls]               │
└─────────────────────────────────────────────────────┘
```

**4. User Level 1 Template:**
```
┌─────────────────────────────────────────────────────┐
│ Header: [Logo] User Level 1 [User Menu] [Logout]   │
├─────────────────────────────────────────────────────┤
│ Sidebar:                                            │
│ - Dashboard                                         │
│ - My Sensor Data                                    │
│ - My Devices                                        │
│                                                     │
│ Main Content:                                       │
│ [User Level 1 content - can view and manage own data]│
└─────────────────────────────────────────────────────┘
```

**5. User Level 2 Template:**
```
┌─────────────────────────────────────────────────────┐
│ Header: [Logo] User Level 2 [User Menu] [Logout]   │
├─────────────────────────────────────────────────────┤
│ Sidebar:                                            │
│ - Dashboard                                         │
│ - View Sensor Data                                  │
│                                                     │
│ Main Content:                                       │
│ [User Level 2 content - view only, limited access] │
└─────────────────────────────────────────────────────┘
```

#### 6.1.3 วิธีการทำ

**1. สร้าง Nuxt 3 Project:**
```bash
npx nuxi@latest init frontend
cd frontend
npm install
```

**2. ติดตั้ง Dependencies:**
```bash
npm install @nuxtjs/tailwindcss axios jwt-decode pinia @pinia/nuxt
```

**3. โครงสร้างไฟล์:**
```
frontend/
├─ pages/
│  ├─ index.vue          # Dashboard
│  ├─ login.vue           # Login Page
│  ├─ sensor-data/
│  │  └─ index.vue        # Sensor Data List
│  └─ devices/
│     └─ index.vue        # Devices List
├─ components/
│  ├─ Layout/
│  │  ├─ Header.vue
│  │  ├─ Sidebar.vue
│  │  └─ Footer.vue
│  └─ Common/
│     ├─ DataTable.vue
│     └─ Chart.vue
├─ stores/
│  ├─ auth.js            # Pinia Store for Auth
│  └─ sensor.js          # Pinia Store for Sensor Data
├─ composables/
│  └─ useApi.js          # API Helper
└─ nuxt.config.ts
```

**4. Tailwind CSS Configuration:**
```javascript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/tailwindcss'],
  css: ['~/assets/css/main.css'],
  runtimeConfig: {
    public: {
      apiBase: process.env.API_BASE_URL || 'http://localhost:3000/api'
    }
  }
})
```

#### 6.1.4 วิธีเช็ค
```bash
# Run Development Server
npm run dev

# Build for Production
npm run build

# Preview Production Build
npm run preview
```

#### 6.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** CORS Error
  - **วิธีแก้:** ตั้งค่า CORS ใน Backend
- **ปัญหา:** JWT Token ไม่ถูกส่ง
  - **วิธีแก้:** ตรวจสอบ Axios Interceptor
- **ระวัง:** ต้องทำ Responsive Design สำหรับ Mobile

#### 6.1.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# Lint Code
npm run lint

# Type Check
npm run typecheck
```

#### 6.1.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม PWA Support
- ใช้ Vuetify หรือ PrimeVue สำหรับ UI Components
- เพิ่ม Dark Mode
- เพิ่ม Internationalization (i18n)

---

## 7. MQTT & Node-RED Design

### 7.1 MQTT Architecture

#### 7.1.1 ความหมาย/การใช้งาน/คืออะไร
MQTT (Message Queuing Telemetry Transport) เป็นโปรโตคอลสำหรับ IoT Devices ในการส่งข้อมูลแบบ Publish/Subscribe

#### 7.1.2 รูปแบบ/Design

**MQTT Topics Structure:**
```
sensor/
  ├─ temp/
  │   ├─ 001          # Temperature Sensor 001
  │   └─ 002          # Temperature Sensor 002
  ├─ humidity/
  │   ├─ 001          # Humidity Sensor 001
  │   └─ 002          # Humidity Sensor 002
  └─ status/
      └─ device001    # Device Status

command/
  ├─ device001/
  │   ├─ on           # Turn On Device
  │   └─ off          # Turn Off Device
  └─ reset            # Reset All Devices
```

**MQTT Broker Configuration:**
- **Broker:** Eclipse Mosquitto
- **Port:** 1883 (MQTT), 9001 (WebSocket)
- **Authentication:** Username/Password
- **ACL:** Topic-based Access Control

#### 7.1.3 วิธีการทำ

**1. MQTT Broker Configuration (mosquitto.conf):**
```
listener 1883
allow_anonymous false
password_file /mosquitto/config/passwd
acl_file /mosquitto/config/acl

# WebSocket
listener 9001
protocol websockets
```

**2. สร้าง Password File:**
```bash
mosquitto_passwd -c /mosquitto/config/passwd mqtt_user
# Password: mqtt_password
```

**3. สร้าง ACL File:**
```
user mqtt_user
topic read sensor/#
topic write sensor/#
topic readwrite command/#
```

#### 7.1.4 วิธีเช็ค
```bash
# ทดสอบ MQTT Publish
mosquitto_pub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "sensor/temp/001" -m "25.5"

# ทดสอบ MQTT Subscribe
mosquitto_sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "sensor/#" -v
```

#### 7.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** MQTT Connection Refused
  - **วิธีแก้:** ตรวจสอบ Port และ Firewall
- **ปัญหา:** Authentication Failed
  - **วิธีแก้:** ตรวจสอบ Username/Password
- **ระวัง:** ต้องตั้งค่า ACL ให้ถูกต้อง

#### 7.1.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# เช็ค MQTT Broker Status
docker logs mqtt

# ทดสอบ MQTT ด้วย MQTT Explorer
# Download: https://mqtt-explorer.com/
# Connect to: 192.168.10.10:1883
```

#### 7.1.7 แนวทางในการพัฒนาในอนาคต
- ใช้ MQTT over TLS/SSL
- เพิ่ม MQTT Bridge
- ใช้ MQTT 5.0 Features

---

### 7.2 Node-RED Design

#### 7.2.1 ความหมาย/การใช้งาน/คืออะไร
Node-RED เป็น Visual Programming Tool สำหรับเชื่อมต่อ Hardware, APIs, และ Services เข้าด้วยกัน

#### 7.2.2 รูปแบบ/Design

**Node-RED Flow Structure:**
```
MQTT In (sensor/temp/#)
  ↓
Function (Process Data)
  ↓
MySQL Insert (Save to Database)
  ↓
MQTT Out (command/device001/on) [Conditional]
  ↓
Dashboard Chart (Visualization)
```

#### 7.2.3 วิธีการทำ

**1. Node-RED Flow Example (flow.json):**
```json
[
  {
    "id": "mqtt-in-1",
    "type": "mqtt in",
    "name": "Sensor Temperature",
    "topic": "sensor/temp/#",
    "qos": "1",
    "broker": "mqtt-broker-1",
    "x": 100,
    "y": 100
  },
  {
    "id": "function-1",
    "type": "function",
    "name": "Process Data",
    "func": "const data = JSON.parse(msg.payload);\nmsg.payload = {\n    sensor_type: 'temperature',\n    sensor_value: parseFloat(data.value),\n    mqtt_topic: msg.topic,\n    timestamp: new Date().toISOString()\n};\nreturn msg;",
    "x": 300,
    "y": 100
  },
  {
    "id": "mysql-1",
    "type": "mysql",
    "name": "Save to Database",
    "host": "db",
    "port": "3306",
    "user": "iot_user",
    "password": "iot_password_123",
    "database": "iot_db",
    "sql": "INSERT INTO sensor_data (user_id, sensor_type, sensor_value, mqtt_topic, timestamp) VALUES (1, '{{payload.sensor_type}}', {{payload.sensor_value}}, '{{payload.mqtt_topic}}', '{{payload.timestamp}}')",
    "x": 500,
    "y": 100
  },
  {
    "id": "dashboard-chart-1",
    "type": "ui_chart",
    "name": "Temperature Chart",
    "group": "dashboard-group-1",
    "x": 700,
    "y": 100
  }
]
```

**2. สร้าง Node-RED Flow:**
- เข้า http://iot.sisat.lan:1880
- ลาก Nodes จาก Palette
- เชื่อมต่อ Nodes
- Deploy Flow

#### 7.2.4 วิธีเช็ค
```bash
# เข้า Node-RED UI
# http://iot.sisat.lan:1880

# Export Flow
# คลิก Menu > Export > Current Flow

# Import Flow
# คลิก Menu > Import > Paste JSON
```

#### 7.2.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** Node-RED ไม่สามารถเชื่อมต่อ Database ได้
  - **วิธีแก้:** ตรวจสอบ Database Connection และ Install node-red-node-mysql
- **ปัญหา:** MQTT Node ไม่ทำงาน
  - **วิธีแก้:** ตรวจสอบ MQTT Broker Configuration
- **ระวัง:** ต้อง Install Additional Nodes สำหรับ MySQL, Dashboard

#### 7.2.6 คำสั่งที่ใช้ในการตรวจสอบ

**Install Node-RED Nodes:**
```bash
# ใน Node-RED Container
docker exec -it nodered npm install node-red-node-mysql
docker exec -it nodered npm install node-red-dashboard
docker restart nodered
```

**Export/Import Flow:**
- Export: Menu > Export > Current Flow > Copy to Clipboard
- Import: Menu > Import > Paste JSON > Deploy

#### 7.2.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Custom Nodes
- ใช้ Node-RED Dashboard สำหรับ Real-time Monitoring
- เพิ่ม Alert/Notification System

---

### 7.3 ESP32 Integration

#### 7.3.1 ความหมาย/การใช้งาน/คืออะไร
ESP32 เป็น Microcontroller ที่มี WiFi Built-in ใช้สำหรับเชื่อมต่อกับ MQTT Broker และส่งข้อมูล Sensor

#### 7.3.2 รูปแบบ/Design

**ESP32 Code Structure:**
```cpp
#include <WiFi.h>
#include <PubSubClient.h>

// WiFi Credentials (เชื่อมต่อกับ Access Point ใน VLAN XX)
const char* ssid = "@wifi";
const char* password = "12345678";

// MQTT Broker
const char* mqtt_server = "192.168.10.10";
const int mqtt_port = 1883;
const char* mqtt_user = "mqtt_user";
const char* mqtt_password = "mqtt_password";

// MQTT Topics
const char* pub_topic = "sensor/temp/001";
const char* sub_topic = "command/device001/#";

WiFiClient espClient;
PubSubClient client(espClient);

void setup() {
  // Connect WiFi
  // Connect MQTT
  // Setup Sensor
}

void loop() {
  // Read Sensor
  // Publish to MQTT
  // Subscribe to Commands
  delay(5000);
}
```

#### 7.3.3 วิธีการทำ

**1. ESP32 Arduino Code:**
```cpp
#include <WiFi.h>
#include <PubSubClient.h>
#include <DHT.h>

#define DHT_PIN 4
#define DHT_TYPE DHT22

DHT dht(DHT_PIN, DHT_TYPE);

// WiFi Credentials (เชื่อมต่อกับ Access Point ใน VLAN XX)
const char* ssid = "@wifi";
const char* password = "12345678";
const char* mqtt_server = "192.168.10.10";
const char* mqtt_user = "mqtt_user";
const char* mqtt_password = "mqtt_password";
const char* pub_topic_temp = "sensor/temp/001";
const char* pub_topic_humidity = "sensor/humidity/001";
const char* sub_topic = "command/device001/#";

WiFiClient espClient;
PubSubClient client(espClient);

void setup_wifi() {
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("WiFi connected");
}

void callback(char* topic, byte* payload, unsigned int length) {
  String message = "";
  for (int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  
  if (String(topic) == "command/device001/on") {
    // Turn on device
  } else if (String(topic) == "command/device001/off") {
    // Turn off device
  }
}

void reconnect() {
  while (!client.connected()) {
    if (client.connect("ESP32Client", mqtt_user, mqtt_password)) {
      client.subscribe(sub_topic);
    } else {
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  dht.begin();
  setup_wifi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  float temp = dht.readTemperature();
  float humidity = dht.readHumidity();
  
  if (!isnan(temp) && !isnan(humidity)) {
    char tempMsg[50];
    char humidityMsg[50];
    sprintf(tempMsg, "{\"value\":%.2f}", temp);
    sprintf(humidityMsg, "{\"value\":%.2f}", humidity);
    
    client.publish(pub_topic_temp, tempMsg);
    client.publish(pub_topic_humidity, humidityMsg);
  }
  
  delay(5000);
}
```

#### 7.3.4 วิธีเช็ค
```bash
# ดู Serial Monitor ใน Arduino IDE
# ควรเห็น:
# WiFi connected
# MQTT connected
# Publishing: sensor/temp/001 {"value":25.5}

# ทดสอบ MQTT Subscribe เพื่อดูข้อมูลจาก ESP32
mosquitto_sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "sensor/#" -v

# ทดสอบส่งคำสั่งไปยัง ESP32
mosquitto_pub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "command/device001/on" -m "1"

# ตรวจสอบข้อมูลใน Database
mysql -u iot_user -p iot_db -e "SELECT * FROM sensor_data ORDER BY timestamp DESC LIMIT 10;"
```

#### 7.3.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** ESP32 ไม่สามารถเชื่อมต่อ WiFi ได้
  - **วิธีแก้:** ตรวจสอบ SSID และ Password, ตรวจสอบ Signal Strength
- **ปัญหา:** MQTT Connection Failed
  - **วิธีแก้:** ตรวจสอบ MQTT Broker IP, Port, Username/Password
- **ปัญหา:** Sensor ไม่ส่งข้อมูล
  - **วิธีแก้:** ตรวจสอบ Sensor Wiring และ Pin Configuration
- **ระวัง:** ต้องใช้ Library ที่ถูกต้อง (PubSubClient, WiFi, DHT)
- **ระวัง:** ต้องตั้งค่า MQTT Keep Alive เพื่อป้องกัน Connection Timeout

#### 7.3.6 คำสั่งที่ใช้ในการตรวจสอบ

**Arduino IDE Setup:**
1. ติดตั้ง ESP32 Board Support:
   - File > Preferences > Additional Board Manager URLs
   - เพิ่ม: `https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json`
   - Tools > Board > Boards Manager > ค้นหา "ESP32" > Install

2. ติดตั้ง Libraries:
   - Sketch > Include Library > Manage Libraries
   - ค้นหาและติดตั้ง:
     - "PubSubClient" by Nick O'Leary
     - "DHT sensor library" by Adafruit
     - "WiFi" (Built-in)

**ESP32 Code Verification:**
```cpp
// ทดสอบ WiFi Connection
void test_wifi() {
  Serial.print("WiFi Status: ");
  Serial.println(WiFi.status());
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
}

// ทดสอบ MQTT Connection
void test_mqtt() {
  if (client.connected()) {
    Serial.println("MQTT Connected");
    client.publish("test/topic", "Hello MQTT");
  } else {
    Serial.println("MQTT Not Connected");
  }
}
```

**MQTT Testing Commands:**
```bash
# ทดสอบ MQTT Broker จากเครื่องอื่น
mosquitto_pub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "test/topic" -m "Test Message"

mosquitto_sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "test/#" -v
```

#### 7.3.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Sensor หลายประเภท (Light, Motion, Gas)
- ใช้ Deep Sleep Mode เพื่อประหยัดพลังงาน
- เพิ่ม OTA (Over-The-Air) Update
- ใช้ MQTT over TLS/SSL
- เพิ่ม Local Storage สำหรับ Offline Mode
- ใช้ ESP32-CAM สำหรับ Image Capture

---

## 8. Flow Diagrams Design

### 8.1 Login Flow

#### 8.1.1 ความหมาย/การใช้งาน/คืออะไร
Login Flow คือกระบวนการเข้าสู่ระบบของผู้ใช้ เริ่มจากการกรอก Username/Password ไปจนถึงการได้รับ JWT Token และเข้าสู่ระบบ

#### 8.1.2 รูปแบบ/Design

```
┌─────────────┐
│  User เข้า   │
│  Login Page │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ กรอก Username   │
│ และ Password    │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ Validate Input │
│ (Frontend)      │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ ส่ง POST Request│
│ /api/auth/login │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ Backend Validate│
│ Username/Pass   │
└──────┬──────────┘
       │
       ├─ Invalid ──► Error Message ──► Return to Login
       │
       ▼ Valid
┌─────────────────┐
│ Query Database  │
│ Check User      │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ Hash Password   │
│ Compare         │
└──────┬──────────┘
       │
       ├─ Not Match ──► Error: Invalid Credentials
       │
       ▼ Match
┌─────────────────┐
│ Generate JWT    │
│ Token           │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ Return Token +  │
│ User Info       │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ Store Token in  │
│ LocalStorage/   │
│ Cookie          │
└──────┬──────────┘
       │
       ▼
┌─────────────────┐
│ Redirect based  │
│ on User Role:   │
│ - Admin         │
│ - User Level 1  │
│ - User Level 2  │
└─────────────────┘
```

#### 8.1.3 วิธีการทำ
1. สร้าง Login Page ใน Frontend (Vue 3)
2. สร้าง API Endpoint `/api/auth/login` ใน Backend
3. Validate Input ทั้ง Frontend และ Backend
4. Query Database เพื่อตรวจสอบ User
5. Hash Password และ Compare
6. Generate JWT Token
7. Return Token และ User Info
8. Store Token ใน Frontend
9. Redirect ตาม Role

#### 8.1.4 วิธีเช็ค
```bash
# ทดสอบ Login API
curl -X POST http://iot.sisat.lan:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin"}'

# ตรวจสอบ Token ใน Browser
# F12 > Application > Local Storage > token
```

#### 8.1.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** Token ไม่ถูกเก็บ
  - **วิธีแก้:** ตรวจสอบ LocalStorage หรือ Cookie Settings
- **ปัญหา:** Password ไม่ Match
  - **วิธีแก้:** ตรวจสอบ Password Hashing Algorithm
- **ระวัง:** ต้อง Hash Password ก่อน Compare

#### 8.1.6 คำสั่งที่ใช้ในการตรวจสอบ
```javascript
// Frontend: Login Function
async function login(username, password) {
  const response = await axios.post('/api/auth/login', {
    username,
    password
  });
  
  if (response.data.status === 'success') {
    localStorage.setItem('token', response.data.data.token);
    localStorage.setItem('user', JSON.stringify(response.data.data.user));
    return true;
  }
  return false;
}
```

#### 8.1.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Two-Factor Authentication (2FA)
- เพิ่ม Remember Me Feature
- เพิ่ม Social Login (Google, Facebook)
- เพิ่ม Password Reset Flow

---

### 8.2 Admin Flow

#### 8.2.1 ความหมาย/การใช้งาน/คืออะไร
Admin Flow คือกระบวนการทำงานของผู้ดูแลระบบ (Admin) ที่มีสิทธิ์สูงสุดในการจัดการ Users, Devices, และ System Settings

#### 8.2.2 รูปแบบ/Design

```
┌─────────────┐
│ Admin Login │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ Admin Dashboard │
│ - Overview      │
│ - Statistics    │
└──────┬──────────┘
       │
       ├─► Users Management
       │   ├─ View All Users
       │   ├─ Create User
       │   ├─ Edit User
       │   └─ Delete User
       │
       ├─► Sensor Data Management
       │   ├─ View All Data
       │   ├─ Filter/Search
       │   ├─ Export Data
       │   └─ Delete Data
       │
       ├─► Device Management
       │   ├─ View All Devices
       │   ├─ Configure Devices
       │   ├─ Control Devices
       │   └─ Device Status
       │
       └─► System Settings
           ├─ MQTT Settings
           ├─ Database Settings
           └─ System Configuration
```

#### 8.2.3 วิธีการทำ
1. ตรวจสอบ User Role หลังจาก Login
2. Redirect ไปยัง Admin Dashboard
3. สร้าง API Endpoints สำหรับ Admin Operations
4. สร้าง UI Components สำหรับ Admin Functions
5. Implement Authorization Middleware

#### 8.2.4 วิธีเช็ค
```bash
# ตรวจสอบ Role ใน Token
# Decode JWT Token และดู role field

# ทดสอบ Admin API
curl -X GET http://iot.sisat.lan:3000/api/users \
  -H "Authorization: Bearer {admin_token}"
```

#### 8.2.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** Non-Admin User เข้าถึง Admin Functions
  - **วิธีแก้:** ตรวจสอบ Role ในทุก API Endpoint
- **ระวัง:** ต้องมี Authorization Check ทุกครั้ง

#### 8.2.6 คำสั่งที่ใช้ในการตรวจสอบ
```javascript
// Backend: Authorization Middleware
function isAdmin(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  
  if (decoded.role !== 'admin') {
    return res.status(403).json({
      status: 'error',
      message: 'Access denied. Admin only.'
    });
  }
  
  req.user = decoded;
  next();
}
```

#### 8.2.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Role-based Permissions (RBAC)
- เพิ่ม Audit Log
- เพิ่ม Activity Monitoring

---

### 8.3 User Level 1 Flow

#### 8.3.1 ความหมาย/การใช้งาน/คืออะไร
User Level 1 Flow คือกระบวนการทำงานของผู้ใช้ระดับ 1 ที่สามารถดูและจัดการข้อมูลของตนเองได้ แต่ไม่สามารถจัดการ Users อื่นได้

#### 8.3.2 รูปแบบ/Design

```
┌─────────────┐
│ User L1     │
│ Login       │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ User L1         │
│ Dashboard       │
└──────┬──────────┘
       │
       ├─► My Sensor Data
       │   ├─ View My Data
       │   ├─ Add Data
       │   ├─ Edit My Data
       │   └─ Delete My Data
       │
       ├─► My Devices
       │   ├─ View My Devices
       │   ├─ Configure My Devices
       │   └─ Control My Devices
       │
       └─► Profile
           ├─ View Profile
           └─ Edit Profile
```

#### 8.3.3 วิธีการทำ
1. ตรวจสอบ User Role = 'user_level_1'
2. Filter Data ตาม user_id
3. อนุญาตให้จัดการเฉพาะข้อมูลของตนเอง

#### 8.3.4 วิธีเช็ค
```bash
# ทดสอบ User Level 1 API
curl -X GET http://iot.sisat.lan:3000/api/sensor-data \
  -H "Authorization: Bearer {user_level_1_token}"
# ควรได้เฉพาะข้อมูลของ User นั้น
```

#### 8.3.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** User Level 1 เข้าถึงข้อมูลของ User อื่น
  - **วิธีแก้:** ตรวจสอบ user_id ในทุก Query
- **ระวัง:** ต้อง Filter Data ตาม user_id เสมอ

#### 8.3.6 คำสั่งที่ใช้ในการตรวจสอบ
```javascript
// Backend: Filter by User ID
app.get('/api/sensor-data', authenticateToken, async (req, res) => {
  const userId = req.user.id;
  const role = req.user.role;
  
  let query = 'SELECT * FROM sensor_data';
  if (role !== 'admin') {
    query += ` WHERE user_id = ${userId}`;
  }
  
  // Execute query...
});
```

#### 8.3.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Data Sharing ระหว่าง Users
- เพิ่ม Team/Group Management

---

### 8.4 User Level 2 Flow

#### 8.4.1 ความหมาย/การใช้งาน/คืออะไร
User Level 2 Flow คือกระบวนการทำงานของผู้ใช้ระดับ 2 ที่มีสิทธิ์ต่ำสุด สามารถดูข้อมูลได้เท่านั้น ไม่สามารถแก้ไขหรือลบได้

#### 8.4.2 รูปแบบ/Design

```
┌─────────────┐
│ User L2     │
│ Login       │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ User L2         │
│ Dashboard       │
└──────┬──────────┘
       │
       ├─► View Sensor Data
       │   └─ Read Only
       │
       ├─► View Devices
       │   └─ Read Only
       │
       └─► View Profile
           └─ Read Only
```

#### 8.4.3 วิธีการทำ
1. ตรวจสอบ User Role = 'user_level_2'
2. อนุญาตเฉพาะ GET Requests
3. Block POST, PUT, DELETE Requests

#### 8.4.4 วิธีเช็ค
```bash
# ทดสอบ User Level 2 API
curl -X GET http://iot.sisat.lan:3000/api/sensor-data \
  -H "Authorization: Bearer {user_level_2_token}"

# ทดสอบ POST (ควร Fail)
curl -X POST http://iot.sisat.lan:3000/api/sensor-data \
  -H "Authorization: Bearer {user_level_2_token}" \
  -H "Content-Type: application/json" \
  -d '{"sensor_type":"temp","sensor_value":25.5}'
# ควรได้ 403 Forbidden
```

#### 8.4.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** User Level 2 สามารถ POST/PUT/DELETE ได้
  - **วิธีแก้:** ตรวจสอบ Role และ HTTP Method
- **ระวัง:** ต้อง Block Write Operations สำหรับ User Level 2

#### 8.4.6 คำสั่งที่ใช้ในการตรวจสอบ
```javascript
// Backend: Check Write Permission
function canWrite(req, res, next) {
  if (req.user.role === 'user_level_2') {
    return res.status(403).json({
      status: 'error',
      message: 'Read-only access. Cannot modify data.'
    });
  }
  next();
}

// Apply to Routes
app.post('/api/sensor-data', authenticateToken, canWrite, createSensorData);
app.put('/api/sensor-data/:id', authenticateToken, canWrite, updateSensorData);
app.delete('/api/sensor-data/:id', authenticateToken, canWrite, deleteSensorData);
```

#### 8.4.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Request Permission System
- เพิ่ม Data Export สำหรับ User Level 2

---

### 8.5 System Flow Overview

#### 8.5.1 ความหมาย/การใช้งาน/คืออะไร
System Flow Overview คือภาพรวมของระบบทั้งหมด ตั้งแต่ ESP32 ส่งข้อมูล ไปจนถึงการแสดงผลบน Dashboard

#### 8.5.2 รูปแบบ/Design

```
┌─────────────┐
│   ESP32     │
│  + Sensor   │
└──────┬──────┘
       │
       │ WiFi Connect (@wifi)
       │
       ▼
┌─────────────┐
│ Access Point│
│ @wifi (VLAN XX)│
└──────┬──────┘
       │
       │ Network (VLAN XX)
       │
       ▼
┌─────────────┐
│ MQTT Broker │
│ (Mosquitto) │
└──────┬──────┘
       │
       ├─► Publish: sensor/temp/001
       │
       ▼
┌─────────────┐
│  Node-RED   │
│   Flow      │
└──────┬──────┘
       │
       ├─► Subscribe MQTT
       ├─► Process Data
       ├─► Save to Database
       └─► Send Command (if needed)
       │
       ▼
┌─────────────┐
│  Database   │
│ (MariaDB)   │
└──────┬──────┘
       │
       │
       ▼
┌─────────────┐
│  Backend    │
│  (Node.js)  │
└──────┬──────┘
       │
       ├─► RESTful API
       │   ├─ GET /api/sensor-data
       │   ├─ POST /api/sensor-data
       │   └─ ...
       │
       ▼
┌─────────────┐
│  Frontend   │
│ (Vue 3)     │
└──────┬──────┘
       │
       ├─► Dashboard
       ├─► Charts
       ├─► Tables
       └─► Real-time Updates
       │
       ▼
┌─────────────┐
│   User      │
│  Browser    │
└─────────────┘
```

#### 8.5.3 วิธีการทำ
1. ESP32 ส่งข้อมูล Sensor ไปยัง MQTT Broker
2. Node-RED Subscribe และ Process ข้อมูล
3. Node-RED บันทึกข้อมูลลง Database
4. Backend API อ่านข้อมูลจาก Database
5. Frontend เรียก API และแสดงผล
6. User ดูข้อมูลบน Dashboard

#### 8.5.4 วิธีเช็ค
```bash
# 1. ตรวจสอบ MQTT Message
mosquitto_sub -h 192.168.10.10 -p 1883 -u mqtt_user -P mqtt_password \
  -t "sensor/#" -v

# 2. ตรวจสอบ Database
mysql -u iot_user -p iot_db -e "SELECT * FROM sensor_data ORDER BY timestamp DESC LIMIT 5;"

# 3. ตรวจสอบ Backend API
curl -X GET http://iot.sisat.lan:3000/api/sensor-data \
  -H "Authorization: Bearer {token}"

# 4. ตรวจสอบ Frontend
# เปิด Browser: http://iot.sisat.lan:3001
```

#### 8.5.5 ปัญหาที่ต้องเจอ/ข้อความระวัง
- **ปัญหา:** ข้อมูลไม่ถึง Database
  - **วิธีแก้:** ตรวจสอบ Node-RED Flow และ Database Connection
- **ปัญหา:** Frontend ไม่แสดงข้อมูล
  - **วิธีแก้:** ตรวจสอบ API Response และ CORS Settings
- **ระวัง:** ต้องตรวจสอบทุก Component ใน Flow

#### 8.5.6 คำสั่งที่ใช้ในการตรวจสอบ
```bash
# ตรวจสอบทุก Component
# 1. MQTT
docker logs mqtt

# 2. Node-RED
docker logs nodered
# เข้า http://iot.sisat.lan:1880

# 3. Database
docker exec -it db mysql -u iot_user -p iot_db

# 4. Backend
docker logs backend
curl http://iot.sisat.lan:3000/api/health

# 5. Frontend
docker logs frontend
curl http://iot.sisat.lan:3001
```

#### 8.5.7 แนวทางในการพัฒนาในอนาคต
- เพิ่ม Message Queue (RabbitMQ, Kafka)
- เพิ่ม Real-time Updates ด้วย WebSocket
- เพิ่ม Caching Layer (Redis)
- เพิ่ม Load Balancer
- เพิ่ม Monitoring และ Alerting System

---

## 9. สรุป (Summary)

### 9.1 สรุปการออกแบบ
Design Phase นี้ครอบคลุมการออกแบบระบบ IoT ทั้งหมด ตั้งแต่ Network Architecture, DevOps, Database, API, Frontend, MQTT, Node-RED, และ ESP32 Integration โดยเน้นความง่ายและความเร็วในการพัฒนาเพื่อให้สามารถทำได้ภายใน 24 ชั่วโมง

### 9.2 จุดสำคัญที่ต้องระวัง
1. **Network Configuration:** ต้องตั้งค่า IP, DNS, และ Network ให้ถูกต้อง
2. **Security:** ต้อง Hash Password, ใช้ JWT Token, และตั้งค่า ACL
3. **Authorization:** ต้องตรวจสอบ Role และ Permission ทุกครั้ง
4. **Data Flow:** ต้องตรวจสอบ Flow จาก ESP32 ไปจนถึง Frontend
5. **Testing:** ต้องทดสอบทุก Component ก่อน Deploy

### 9.3 ขั้นตอนต่อไป
หลังจาก Design Phase เสร็จแล้ว ขั้นตอนต่อไปคือ:
1. **Implementation Phase:** พัฒนาระบบตาม Design ที่กำหนด
2. **Testing Phase:** ทดสอบระบบทั้งหมด
3. **Deployment Phase:** Deploy ไปยัง Production Server
4. **Documentation Phase:** เขียน Documentation และ User Manual

---

**สิ้นสุด Design Phase**